Exercise Number,Question Text,Chapter_name
Exercise 1.1,Review the documentation for your compiler and determine what file,Getting started
Exercise 1.2,Change the program to return -1. A return value of -1 is often treated.,Getting started
Exercise 1.3,"Write a program to print He11o, Wor1d on the standard output.",Getting started
Exercise 1.4,"Our program used the addition operator, +, to add two numbers. Write",Getting started
Exercise 1.5,We wrote the output in one large statement. Rewrite the program to use,Getting started
Exercise 1.6,Explain whether the following program fragment is legal,Getting started
Exercise 1.7,Compile a program that has incorrectly nested comments.,Getting started
Exercise 1.8,"Indicate which, if any, of the following output statements are legal",Getting started
Exercise 1.9,Write a program that uses a whi1e to sum the numbers from 50 to 100.,Getting started
Exercise 1.10,"In addition to the ++ operator that adds 1 to its operand, there is a.",Getting started
Exercise 1.11,Write a program that prompts the user for two integers. Print each.,Getting started
Exercise 1.12,What does the following for loop do? What is the final value of sum?,Getting started
Exercise 1.13,Rewrite the first two exercises from S 1.4.1 (p. 13) using for loops,Getting started
Exercise 1.14,Compare and contrast the loops that used a for with those using a,Getting started
Exercise 1.15,Write programs that contain the common errors discussed in the box,Getting started
Exercise 1.16,Write your own version of a program that prints the sum of a set of.,Getting started
Exercise 1.17,What happens in the program presented in this section if the input val,Getting started
Exercise 1.18,Compile and run the program from this section giving it only equal,Getting started
Exercise 1.19,Revise the program you wrote for the exercises in $ 1.4.1 (p. 13) that.,Getting started
Exercise 1.21,Write a program that reads two Sales_item objects that have the,Getting started
Exercise 1.22,Write a program that reads several transactions for the same IsBN.,Getting started
Exercise 1.23,Write a program that reads several transactions and counts how many,Getting started
Exercise 1.24,Test the previous program by giving multiple transactions representing.,Getting started
Exercise 1.25,"Using the Sales_item.h header from the Web site, compile and exe-",Getting started
Exercise 2.1,"What are the differences between int, long, long long, and short?",Variable and Basic types
Exercise 2.2,"To calculate a mortgage payment, what types would you use for the rate,",Variable and Basic types
Exercise 2.3,What output will the following code produce?,Variable and Basic types
Exercise 2.4,"Write a program to check whether your predictions were correct. If not,",Variable and Basic types
Exercise 2.5,Determine the type of each of the following literals. Explain the differ-,Variable and Basic types
Exercise 2.6,"What, if any, are the differences between the following definitions:",Variable and Basic types
Exercise 2.7,What values do these literals represent? What type does each have?,Variable and Basic types
Exercise 2.8,"Using escape sequences, write a program to print 2M followed by a new-.",Variable and Basic types
Exercise 2.9,"Explain the following definitions. For those that are illegal, explain",Variable and Basic types
Exercise 2.10,"What are the initial values, if any, of each of the following variables?",Variable and Basic types
Exercise 2.11,Explain whether each of the following is a declaration or a definition:,Variable and Basic types
Exercise 2.12,"Which, if any, of the following names are invalid?",Variable and Basic types
Exercise 2.13,What is the value of j in the following program?,Variable and Basic types
Exercise 2.14,"Is the following program legal? If so, what values are printed?",Variable and Basic types
Exercise 2.15,"Which of the following definitions, if any, are invalid? Why?",Variable and Basic types
Exercise 2.16,"Which, if any, of the following assignments are invalid? If they are",Variable and Basic types
Exercise 2.17,What does the following code print?,Variable and Basic types
Exercise 2.18,Write code to change the value of a pointer. Write code to change the,Variable and Basic types
Exercise 2.19,Explain the key differences between pointers and references.,Variable and Basic types
Exercise 2.20,What does the following program do?,Variable and Basic types
Exercise 2.21,Explain each of the following definitions. Indicate whether any are il-,Variable and Basic types
Exercise 2.22,"Assuming p is a pointer to int, explain the following code:",Variable and Basic types
Exercise 2.23,"Given a pointer p, can you determine whether p points to a valid object?",Variable and Basic types
Exercise 2.24,Why is the initialization of p legal but that of 1p illegal?,Variable and Basic types
Exercise 2.25,Determine the types and values of each of the following variables,Variable and Basic types
Exercise 2.26,"Which of the following are legal? For those that are illegal, explain why.",Variable and Basic types
Exercise 2.27,Which of the following initializations are legal? Explain why,Variable and Basic types
Exercise 2.28,Explain the following definitions. Identify any that are illegal.,Variable and Basic types
Exercise 2.29,"Uing the variables in the previous exercise, which of the following as-",Variable and Basic types
Exercise 2.30,For each of the following declarations indicate whether the object being,Variable and Basic types
Exercise 2.31,Given the declarations in the previous exercise determine whether the,Variable and Basic types
Exercise 2.32,"Is the following code legal or not? If not, how might you make it legal?",Variable and Basic types
Exercise 2.33,"Using the variable definitions from this section, determine what hap",Variable and Basic types
Exercise 2.34,Write a program containing the variables and assignments from the,Variable and Basic types
Exercise 2.35,Determine the types deduced in each of the following definitions. Once,Variable and Basic types
Exercise 2.36,"In the following code, determine the type of each variable and the value",Variable and Basic types
Exercise 2.37,Assignment is an example of an expression that yields a reference type.,Variable and Basic types
Exercise 2.38,Describe the differences in type deduction between decltype and,Variable and Basic types
Exercise 2.39,Compile the following program to see what happens when you forget.,Variable and Basic types
Exercise 2.40,Write your own version of the Sales_data class..,Variable and Basic types
Exercise 2.41,"Use your Sales_data class to rewrite the exercises in S 1.5.1 (p. 22),",Variable and Basic types
Exercise 2.42,Write your own version of the Sales_data.h header and use it to.,Variable and Basic types
Exercise 3.1,Rewrite the exercises from  1.4.1 (p. 13) and S 2.6.2 (p. 76) with appro,"Strings, Vectors, and Arrays"
Exercise 3.2,Write a program to read the standard input a line at a time. Modify your,"Strings, Vectors, and Arrays"
Exercise 3.3,Explain how whitespace characters are handled in the string input op-.,"Strings, Vectors, and Arrays"
Exercise 3.4,Write a program to read two strings and report whether the strings.,"Strings, Vectors, and Arrays"
Exercise 3.5,"Write a program to read strings from the standard input, concatenat-","Strings, Vectors, and Arrays"
Exercise 3.6,Use a range for to change all the characters in a string to X.,"Strings, Vectors, and Arrays"
Exercise 3.7,What would happen if you define the loop control variable in the previ-,"Strings, Vectors, and Arrays"
Exercise 3.8,"Rewrite the program in the first exercise, first using a whi1e and again","Strings, Vectors, and Arrays"
Exercise 3.9,"What does the following program do? Is it valid? If not, why not?.","Strings, Vectors, and Arrays"
Exercise 3.10,Write a program that reads a string of characters including punctuation,"Strings, Vectors, and Arrays"
Exercise 3.11,"Is the following range for legal? If so, what is the type of c?","Strings, Vectors, and Arrays"
Exercise 3.12,"Which, if any, of the following vector definitions are in error? For.","Strings, Vectors, and Arrays"
Exercise 3.13,How many elements are there in each of the following vectors? What,"Strings, Vectors, and Arrays"
Exercise 3.14,Write a program to read a sequence of ints from cin and store those,"Strings, Vectors, and Arrays"
Exercise 3.15,Repeat the previous program but read strings this time.,"Strings, Vectors, and Arrays"
Exercise 3.16,Write a program to print the size and contents of the vectors from,"Strings, Vectors, and Arrays"
Exercise 3.17,Read a sequence of words from cin and store the values a vector. Af-,"Strings, Vectors, and Arrays"
Exercise 3.18,"Is the following program legal? If not, how might you fix it?","Strings, Vectors, and Arrays"
Exercise 3.19,"List three ways to define a vector and give it ten elements, each with","Strings, Vectors, and Arrays"
Exercise 3.20,Read a set of integers into a vector. Print the sum of each pair of,"Strings, Vectors, and Arrays"
Exercise 3.21,Redo the first exercise from $ 3.3.3 (p. 105) using iterators.,"Strings, Vectors, and Arrays"
Exercise 3.22,Revise the loop that printed the first paragraph in text to instead,"Strings, Vectors, and Arrays"
Exercise 3.23,Write a program to create a vector with ten int elements. Using an.,"Strings, Vectors, and Arrays"
Exercise 3.24,Redo the last exercise from S 3.3.3 (p. 105) using iterators.,"Strings, Vectors, and Arrays"
Exercise 3.25,Rewrite the grade clustering program from S 3.3.3 (p. 104) using itera-,"Strings, Vectors, and Arrays"
Exercise 3.26,"In the binary search program on page 112, why did we write mid = beg","Strings, Vectors, and Arrays"
Exercise 3.27,Assuming txt_si ze is a function that takes no arguments and returns.,"Strings, Vectors, and Arrays"
Exercise 3.28,What are the values in the following arrays?.,"Strings, Vectors, and Arrays"
Exercise 3.29,List some of the drawbacks of using an array instead of a vector.,"Strings, Vectors, and Arrays"
Exercise 3.30,Identify the indexing errors in the following code:,"Strings, Vectors, and Arrays"
Exercise 3.31,Write a program to define an array of ten ints. Give each element the.,"Strings, Vectors, and Arrays"
Exercise 3.32,Copy the array you defined in the previous exercise into another array.,"Strings, Vectors, and Arrays"
Exercise 3.33,What would happen if we did not initialize the scores array in the,"Strings, Vectors, and Arrays"
Exercise 3.34,"Given that p1 and p2 point to elements in the same array, what does","Strings, Vectors, and Arrays"
Exercise 3.35,"Using pointers, write a program to set the elements in an array to zero.","Strings, Vectors, and Arrays"
Exercise 3.36,Write a program to compare two arrays for equality. Write a similar,"Strings, Vectors, and Arrays"
Exercise 3.37,What does the following program do?,"Strings, Vectors, and Arrays"
Exercise 3.38,"In this section, we noted that it was not only illegal but meaningless to.","Strings, Vectors, and Arrays"
Exercise 3.39,Write a program to compare two strings. Now write a program to.,"Strings, Vectors, and Arrays"
Exercise 3.40,Write a program to define two character arrays initialized from string,"Strings, Vectors, and Arrays"
Exercise 3.41,Write a program to initialize a vector from an array of ints.,"Strings, Vectors, and Arrays"
Exercise 3.42,Write a program to copy a vector of ints into an array of ints.,"Strings, Vectors, and Arrays"
Exercise 3.43,Write three different versions of a program to print the elements of ia..,"Strings, Vectors, and Arrays"
Exercise 3.44,Rewrite the programs from the previous exercises using a type alias for,"Strings, Vectors, and Arrays"
Exercise 3.45,"Rewrite the programs again, this time using auto.","Strings, Vectors, and Arrays"
Exercise 4.1,What is the value returned by 5 + 10 * 20/2?,Expressions
Exercise 4.2,"Using Table 4.12 (p. 166), parenthesize the following expressions to indi-",Expressions
Exercise 4.3,Order of evaluation for most of the binary operators is left undefined,Expressions
Exercise 4.4,Parenthesize the following expression to show how it is evaluated. Test,Expressions
Exercise 4.5,Determine the result of the following expressions..,Expressions
Exercise 4.6,Write an expression to determine whether an int value is even or odd,Expressions
Exercise 4.7,What does overflow mean? Show three expressions that will overflow.,Expressions
Exercise 4.8,"Explain when operands are evaluated in the logical AND, logical OR, and",Expressions
Exercise 4.9,Explain the behavior of the condition in the following if:.,Expressions
Exercise 4.10,Write the condition for a while loop that would read ints from the,Expressions
Exercise 4.11,"Write an expression that tests four values, a, b, c, and d, and ensures.",Expressions
Exercise 4.12,"Assuming i, j, and k are all ints, explain what i != j < k means.",Expressions
Exercise 4.13,What are the values of i and d after each assignment?,Expressions
Exercise 4.14,Explain what happens in each of the if tests:,Expressions
Exercise 4.15,The following assignment is illegal. Why? How would you correct it?.,Expressions
Exercise 4.16,"Although the following are legal, they probably do not behave as the",Expressions
Exercise 4.17,Explain the difference between prefix and postfix increment..,Expressions
Exercise 4.18,What would happen if the whi1e loop on page 148 that prints the ele,Expressions
Exercise 4.19,"Given that ptr points to an int, that vec is a vector<int >, and that.",Expressions
Exercise 4.20,Assuming that iter is a vector.,Expressions
Exercise 4.21,Write a program to use a conditional operator to find the elements in a,Expressions
Exercise 4.22,"Extend the program that assigned high pass, pass, and fail grades to",Expressions
Exercise 4.23,The following expression fails to compile due to operator precedence.,Expressions
Exercise 4.24,"Our program that distinguished between high pass, pass, and fail de-",Expressions
Exercise 4.25,What is the value of ~' q' << 6 on a machine with 32-bit ints and 8 bit,Expressions
Exercise 4.26,"In our grading example in this section, what would happen if we used",Expressions
Exercise 4.27,What is the result of each of these expressions?,Expressions
Exercise 4.28,Write a program to print the size of each of the built-in types.,Expressions
Exercise 4.29,Predict the output of the following code and explain your reasoning.,Expressions
Exercise 4.30,"Using Table 4.12 (p.166), parenthesize the following expressions to",Expressions
Exercise 4.31,The program in this section used the prefix increment and decrement,Expressions
Exercise 4.32,Explain the following loop,Expressions
Exercise 4.33,Using Table 4.12 (p. 166) explain what the following expression does:,Expressions
Exercise 4.34,"Given the variable definitions in this section, explain what conversions",Expressions
Exercise 4.35,"Given the following definitions,",Expressions
Exercise 4.36,Assuming i is an int and d is a double write the expression i *= d so,Expressions
Exercise 4.37,Rewrite each of the following old-style casts to use a named cast,Expressions
Exercise 4.38,Explain the following expression:,Expressions
Exercise 5.1,What is a null statement? When might you use a null statement?,Statements
Exercise 5.2,What is a block? When might you might use a block?,Statements
Exercise 5.3,"Use the comma operator (S 4.10, p. 157) to rewrite the whi1e loop from",Statements
Exercise 5.4,"Explain each of the following examples, and correct any problems you",Statements
Exercise 5.5,"Using an if-else statement, write your own version of the program to.",Statements
Exercise 5.6,"Rewrite your grading program to use the conditional operator (S 4.7,",Statements
Exercise 5.7,Correct the errors in each of the following code fragments:,Statements
Exercise 5.8,"What is a ""dangling else""? How are else clauses resolved in C++?",Statements
Exercise 5.9,Write a program using a series of if statements to count the number of.,Statements
Exercise 5.10,There is one problem with our vowel-counting program as we've im-,Statements
Exercise 5.11,Modify our vowel-counting program so that it also counts the number.,Statements
Exercise 5.12,Modify our vowel-counting program so that it counts the number of,Statements
Exercise 5.13,Each of the programs in the highlighted text on page 184 contains a.,Statements
Exercise 5.14,Write a program to read strings from standard input looking for du-,Statements
Exercise 5.15,Explain each of the following loops. Correct any problems you detect.,Statements
Exercise 5.16,The whi 1e loop is particularly good at executing while some condition,Statements
Exercise 5.17,"Given two vectors of ints, write a program to determine whether.",Statements
Exercise 5.18,Explain each of the following loops. Correct any problems you detect..,Statements
Exercise 5.19,Write a program that uses a do whi 1e loop to repetitively request two.,Statements
Exercise 5.20,Write a program to read a sequence of strings from the standard input,Statements
Exercise 5.21,Revise the program from the exercise in S 5.5.1 (p. 191) so that it looks,Statements
Exercise 5.22,The last example in this section that jumped back to begin could be.,Statements
Exercise 5.23,Write a program that reads two integers from the standard input and,Statements
Exercise 5.24,Revise your program to throw an exception if the second number is,Statements
Exercise 5.25,Revise your program from the previous exercise to use a try block to,Statements
Exercise 6.1,What is the difference between a parameter and an argument?,Functions
Exercise 6.2,Indicate which of the following functions are in error and why. Suggest,Functions
Exercise 6.3,Write and test your own version of fact..,Functions
Exercise 6.4,"Write a function that interacts with the user, asking for a number and",Functions
Exercise 6.5,Write a function to return the absolute value of its argument..,Functions
Exercise 6.6,"Explain the differences between a parameter, a local variable, and a local",Functions
Exercise 6.7,Write a function that returns 0 when it is first called and then generates,Functions
Exercise 6.8,Write a header file named Chapter6.h that contains declarations for,Functions
Exercise 6.9,Write your own versions of the fact . cc and factMain. cc files. These.,Functions
Exercise 6.10,"Using pointers, write a function to swap the values of two ints. Test",Functions
Exercise 6.11,Write and test your own version of reset that takes a reference..,Functions
Exercise 6.12,Rewrite the program from exercise 6.10 in S 6.2.1 (p. 210) to use refer-,Functions
Exercise 6.13,"Assuming T is the name of a type, explain the difference between a",Functions
Exercise 6.14,Give an example of when a parameter should be a reference type. Give,Functions
Exercise 6.15,Explain the rationale for the type of each of find_char's parameters.,Functions
Exercise 6.16,"The following function, although legal, is less useful than it might be",Functions
Exercise 6.17,Write a function to determine whether a string contains any capital..,Functions
Exercise 6.18,Write declarations for each of the following functions. When you write,Functions
Exercise 6.19,"Given the following declarations, determine which calls are legal and",Functions
Exercise 6.20,When should reference parameters be references to const? What hap.,Functions
Exercise 6.21,Write a function that takes an int and a pointer to an int and returns,Functions
Exercise 6.22,Write a function to swap two int pointers.,Functions
Exercise 6.23,Write your own versions of each of the print functions presented in,Functions
Exercise 6.24,Explain the behavior of the following function. If there are problems in,Functions
Exercise 6.25,Write a main function that takes two arguments. Concatenate the sup,Functions
Exercise 6.26,Write a program that accepts the options presented in this section. Print,Functions
Exercise 6.27,Write a function that takes an initializer_list<int> and pro,Functions
Exercise 6.28,"In the second version of error_msg that has an ErrCode parameter,",Functions
Exercise 6.29,When you use an initializer_1ist in a range for would you ever.,Functions
Exercise 6.30,Compile the version of str_subrange as presented on page 223 to see,Functions
Exercise 6.31,When is it valid to return a reference? A reference to const?,Functions
Exercise 6.32,"Indicate whether the following function is legal. If so, explain what it",Functions
Exercise 6.33,Write a recursive function to print the contents of a vector.,Functions
Exercise 6.34,What would happen if the stopping condition in factoria1 were,Functions
Exercise 6.35,"In the call to factoria1, why did we pass va1 - 1 rather than va1--?",Functions
Exercise 6.36,Write the declaration for a function that returns a reference to an array,Functions
Exercise 6.37,Write three additional declarations for the function in the previous ex-,Functions
Exercise 6.38,Revise the arrPtr function on to return a reference to the array.,Functions
Exercise 6.39,Explain the effect of the second declaration in each one of the following.,Functions
Exercise 6.40,"Which, if either, of the following declarations are errors? Why?.",Functions
Exercise 6.41,"Which, if any, of the following calls are illegal? Why? Which, if any, are.",Functions
Exercise 6.42,"Give the second parameter of make_plura1 (S 6.3.2, p. 224) a default",Functions
Exercise 6.43,Which one of the following declarations and definitions would you put,Functions
Exercise 6.44,Rewrite the isShorter function from S 6.2.2 (p. 211) to be inline.,Functions
Exercise 6.45,Review the programs you've written for the earlier exercises and decide,Functions
Exercise 6.46,"Would it be possible to define isShorter as a constexpr? If so, do",Functions
Exercise 6.47,Revise the program you wrote in the exercises in S 6.3.2 (p. 228) that,Functions
Exercise 6.48,Explain what this loop does and whether it is a good use of assert:,Functions
Exercise 6.49,What is a candidate function? What is a viable function?,Functions
Exercise 6.50,"Given the declarations for f from page 242, list the viable functions, if",Functions
Exercise 6.51,Write all four versions of f. Each function should print a distinguish-,Functions
Exercise 6.52,"Given the following declarations,",Functions
Exercise 6.53,Explain the effect of the second declaration in each one of the following,Functions
Exercise 6.54,Write a declaration for a function that takes two int parameters and,Functions
Exercise 6.55,"Write four functions that add, subtract, multiply, and divide two int",Functions
Exercise 6.56,Call each element in the vector and print their result.,Functions
Exercise 7.1,Write a version of the transaction-processing program from S 1.6 (p. 24).,Classes
Exercise 7.2,Add the combine and isbn members to the Sales_data class you,Classes
Exercise 7.3,Revise your transaction-processing program from S 7.1.1 (p. 256) to use,Classes
Exercise 7.4,Write a class named Person that represents the name and address of,Classes
Exercise 7.5,Provide operations in your Person class to return the name and ad-,Classes
Exercise 7.6,"Define your own versions of the add, read, and print functions",Classes
Exercise 7.7,Rewrite the transaction-processing program you wrote for the exercises,Classes
Exercise 7.8,Why does read define its Sales_data parameter as a plain reference,Classes
Exercise 7.9,Add operations to read and print Person objects to the code you wrote,Classes
Exercise 7.10,What does the condition in the following if statement do?,Classes
Exercise 7.11,Add constructors to your Sales_data class and write a program to.,Classes
Exercise 7.12,Move the definition of the Sales data constructor that takes an,Classes
Exercise 7.13,Rewrite the program from page 255 to use the istream constructor.,Classes
Exercise 7.14,Write a version of the default constructor that explicitly initializes the,Classes
Exercise 7.15,Add appropriate constructors to your Person class.,Classes
Exercise 7.16,"What, if any, are the constraints on where and how often an access spec-",Classes
Exercise 7.17,"What, if any, are the differences between using class or struct?",Classes
Exercise 7.18,What is encapsulation? Why is it useful?,Classes
Exercise 7.19,Indicate which members of your Person class you would declare as,Classes
Exercise 7.20,When are friends useful? Discuss the pros and cons of using friends,Classes
Exercise 7.21,Update your Sales_data class to hide its implementation. The pro-,Classes
Exercise 7.22,Update your Person class to hide its implementation,Classes
Exercise 7.23,Write your own version of the Screen class..,Classes
Exercise 7.24,Give your Screen class three constructors: a default constructor; a con-,Classes
Exercise 7.25,Can Screen safely rely on the default versions of copy and assign-,Classes
Exercise 7.26,Define Sales_data: :avg_ price as an inline function..,Classes
Exercise 7.27,"Add the move, set, and display operations to your version of.",Classes
Exercise 7.28,"What would happen in the previous exercise if the return type of move,",Classes
Exercise 7.29,"Revise your Screen class so that move, set, and display functions",Classes
Exercise 7.30,It is legal but redundant to refer to members through the this pointer.,Classes
Exercise 7.31,"Define a pair of classes X and Y, in which x has a pointer to Y, and Y has.",Classes
Exercise 7.32,Define your own versions of Screen and Window_mgr in which,Classes
Exercise 7.33,What would happen if we gave Screen a size member defined as,Classes
Exercise 7.34,What would happen if we put the typedef of pos in the Screen class,Classes
Exercise 7.35,"Explain the following code, indicating which definition of Type or",Classes
Exercise 7.36,The following initializer is in error. Identify and fix the problem.,Classes
Exercise 7.37,"Using the version of Sales_data from this section, determine which",Classes
Exercise 7.38,We might want to supply cin as a default argument to the constructor,Classes
Exercise 7.39,Would it be legal for both the constructor that takes a string and the,Classes
Exercise 7.40,Choose one of the following abstractions (or an abstraction of your,Classes
Exercise 7.41,Rewrite your own version of the Sales_data class to use delegating,Classes
Exercise 7.42,"For the class you wrote for exercise 7.40 in S 7.5.1 (p. 291), decide",Classes
Exercise 7.43,Assume we have a class named NoDefau1t that has a constructor that.,Classes
Exercise 7.44,"Is the following declaration legal? If not, why not?.",Classes
Exercise 7.45,What if we defined the vector in the previous execercise to hold ob,Classes
Exercise 7.46,"Which, if any, of the following statements are untrue? Why?.",Classes
Exercise 7.47,Explain whether the Sales_data constructor that takes a string,Classes
Exercise 7.48,"Assuming the Sales_data constructors are not explicit, what op-",Classes
Exercise 7.49,"For each of the three following declarations of combine, explain what",Classes
Exercise 7.50,Determine whether any of your Person class constructors should be,Classes
Exercise 7.51,Why do you think vector defines its single-argument constructor as,Classes
Exercise 7.52,"Using our first version of Sa1es_data from  2.6.1 (p. 72), explain the.",Classes
Exercise 7.53,Define your own version of Debug.,Classes
Exercise 7.54,Should the members of Debug that begin with set be declared as,Classes
Exercise 7.55,"Is the Dat a class from $ 7.5.5 (p. 298) a literal class? If not, why not? If",Classes
Exercise 7.56,What is a static class member? What are the advantages of static,Classes
Exercise 7.57,Write your own version of the Account class.,Classes
Exercise 7.58,"Which, if any, of the following static data member declarations and.",Classes
Exercise 8.1,Write a function that takes and returns an istream&. The function,Streams and IO Library
Exercise 8.2,"Test your function by calling it, passing cin as an argument.",Streams and IO Library
Exercise 8.3,What causes the following whi1e to terminate?,Streams and IO Library
Exercise 8.4,Write a function to open a file for input and read its contents into a.,Streams and IO Library
Exercise 8.5,Rewrite the previous program to store each word in a separate element.,Streams and IO Library
Exercise 8.6,Rewrite the bookstore program from S 7.1.1 (p. 256) to read its transac-,Streams and IO Library
Exercise 8.7,Revise the bookstore program from the previous section to write its out-,Streams and IO Library
Exercise 8.8,Revise the program from the previous exercise to append its output to,Streams and IO Library
Exercise 8.9,Use the function you wrote for the first exercise in $ 8.1.2 (p. 314) to print,Streams and IO Library
Exercise 8.10,Write a program to store each line from a file in a vector<string>.,Streams and IO Library
Exercise 8.11,The program in this section defined its istringstream object inside,Streams and IO Library
Exercise 8.12,Why didn't we use in-class initializers in PersonInfo?,Streams and IO Library
Exercise 8.13,Rewrite the phone number program from this section to read from a,Streams and IO Library
Exercise 8.14,Why did we declare entry and nums as const auto &?,Streams and IO Library
Exercise 9.1,"Which is the most appropriate- a vector, a deque, or a list-for the",Sequential Containers
Exercise 9.2,Define a list that holds elements that are deques that hold ints..,Sequential Containers
Exercise 9.3,What are the constraints on the iterators that form iterator ranges?,Sequential Containers
Exercise 9.4,Write a function that takes a pair of iterators to a vector<int > and an,Sequential Containers
Exercise 9.5,Rewrite the previous program to return an iterator to the requested ele-,Sequential Containers
Exercise 9.6,What is wrong with the following program? How might you correct it?.,Sequential Containers
Exercise 9.7,What type should be used as the index into a vector of ints?.,Sequential Containers
Exercise 9.8,What type should be used to read elements in a 1ist of strings? To,Sequential Containers
Exercise 9.9,What is the difference between the begin and cbegin functions?,Sequential Containers
Exercise 9.10,What are the types of the following four objects?,Sequential Containers
Exercise 9.11,Show an example of each of the six ways to create and initialize a,Sequential Containers
Exercise 9.12,Explain the differences between the constructor that takes a container,Sequential Containers
Exercise 9.13,How would you initialize a vector<double> from a 1ist<int>?,Sequential Containers
Exercise 9.14,Write a program to assign the elements from a 1ist of char* pointers,Sequential Containers
Exercise 9.15,Write a program to determine whether two vector<int >s are equal..,Sequential Containers
Exercise 9.16,"Repeat the previous program, but compare elements in a 1ist<int >",Sequential Containers
Exercise 9.17,"Assuming c1 and c2 are containers, what (if any) constraints does the.",Sequential Containers
Exercise 9.18,Write a program to read a sequence of strings from the standard input,Sequential Containers
Exercise 9.19,Rewrite the program from the previous exercise to use a 1ist. List the,Sequential Containers
Exercise 9.20,Write a program to copy elements from a 1ist<int > into two deques.,Sequential Containers
Exercise 9.21,Explain how the loop from page 345 that used the return from insert,Sequential Containers
Exercise 9.22,"Assuming iv is a vector of ints, what is wrong with the following.",Sequential Containers
Exercise 3.16,"Write a program to print the size and contents of the vectors from exercise 3.13. Check whether your answers to that exercise were correct. If not, restudy $ 3.3.1 (p. 97) until you understand why you were wrong.","Strings, Vectors, and Arrays"
Exercise 3.17,"Read a sequence of words from cin and store the values a vector. Af- ter you've read all the words, process the vect or and change each word to uppercase. Print the transformed elements, eight words to a line..","Strings, Vectors, and Arrays"
Exercise 3.18,"Is the following program legal? If not, how might you fix it? vector<int> ivec; ivec[0] = 42;","Strings, Vectors, and Arrays"
Exercise 3.19,"List three ways to define a vector and give it ten elements, each with the value 42. Indicate whether there is a preferred way to do so and why,","Strings, Vectors, and Arrays"
Exercise 3.20,"Read a set of integers into a vector. Print the sum of each pair of adjacent elements. Change your program so that it prints the sum of the first and last elements, followed by the sum of the second and second-to-last, and so on.","Strings, Vectors, and Arrays"
Exercise 3.21,Redo the first exercise from  3.3.3 (p.105) using iterators.,"Strings, Vectors, and Arrays"
Exercise 3.22,"Revise the loop that printed the first paragraph in text to instead. change the elements in text that correspond to the first paragraph to all uppercase. After you've updated text, print its contents.","Strings, Vectors, and Arrays"
Exercise 3.23,"Write a program to create a vector with ten int elements. Using an. iterator, assign each element a value that is twice its current value. Test your program. by printing the vector.","Strings, Vectors, and Arrays"
Exercise 3.24,Redo the last exercise from  3.3.3 (p. 105) using iterators,"Strings, Vectors, and Arrays"
Exercise 3.25,Rewrite the grade clustering program from  3.3.3 (p. 104) using itera- tors instead of subscripts..,"Strings, Vectors, and Arrays"
Exercise 3.26,"In the binary search program on page 112, why did we write mid = beg + (end -beg)/2;instead of mid= (beg + end)/2;? 3.5 Arrays An array is a data structure that is similar to the library vector type ($ 3.3, p. 96) but offers a different trade-off between performance and flexibility. Like a vect or. an array is a container of unnamed objects of a single type that we access by posi- tion. Unlike a vector, arrays have fixed size; we cannot add elements to an array. Because arrays have fixed size, they sometimes offer better run-time performance for specialized applications. However, that run-time advantage comes at the cost of lost flexibility. If you don't know exactly how many elements you need, use a vector. 3.5.1 Defining and Initializing Built-in Arrays Arrays are a compound type (S 2.3, p.50).An array declarator has the form a [d] where a is the name being defined and d is the dimension of the array. The dimen sion specifies the number of elements and must be greater than zero. The number of elements in an array is part of the array's type. As a result, the dimension must be known at compile time, which means that the dimension must be a constant expression (S2.4.4, p. 65): unsigned cnt = 42; not a constant expression constexpr unsigned sz = 42; // constant expression // constexprsee $2.4.4 (p.66) int arr[10]; arrayof ten ints int *parr[sz]; //array of 42 pointers to int. string bad[cnt]; error: cnt is not a constant expression string strs [get_size()]; // okifget_sizeis constexpr,error otherwise By default, the elements in an array are default initialized ($ 2.2.1, p. 43) As with variables of built-in type, a default-initialized array of built-in WARNING type that is defined inside a function will have undefined values. When we define an array, we must specify a type for the array. We cannot use auto to deduce the type from a list of initializers. As with vector, arrays hold objects. Thus, there are no arrays of references.","Strings, Vectors, and Arrays"
Exercise 3.27,"Assuming txt_si ze is a function that takes no arguments and returns an int value, which of the following definitions are illegal? Explain why unsigned buf_size = 1024; a int ia[buf_size]; b int ia[4 *7-14]; (c) int ia[txt_size()]; d) char st[11] = ""fundamental"";","Strings, Vectors, and Arrays"
Exercise 3.28,What are the values in the following arrays? string sa[10]; int ia[10]; int main() string sa2[10]; int ia2 [10]; },"Strings, Vectors, and Arrays"
Exercise 3.29,List some of the drawbacks of using an array instead of a vector..,"Strings, Vectors, and Arrays"
Exercise 3.30,Identify the indexing errors in the following code constexpr size_t array_size = 10; int ia[array_size]; for (size t ix = 1; ix <= array_size; ++ix) ia[ix] = ix,"Strings, Vectors, and Arrays"
Exercise 3.31,Write a program to define an array of ten ints. Give each element the same value as its position in the array.,"Strings, Vectors, and Arrays"
Exercise 3.32,Copy the array you defined in the previous exercise into another array. Rewrite your program to use vect ors.,"Strings, Vectors, and Arrays"
Exercise 3.33,"What would happen if we did not initialize the scores array in the program on page 116? 3.5.3Pointers and Arrays In C++ pointers and arrays are closely intertwined. In particular, as well see, when we use an array, the compiler ordinarily converts the array to a pointer.. Normally, we obtain a pointer to an object by using the address-of operator (S 2.3.2, p. 52). Generally speaking, the address-of operator may be applied to any object. The elements in an array are objects. When we subscript an array, the result is the object at that location in the array. As with any other object, we can obtain a pointer to an array element by taking the address of that element: string nums[] ={""one,""two"",""three""};// arrayofstrings string +p = &nums [o];// p points to the first element in nums However, arrays have a special property-in most places when we use an array, the compiler automatically substitutes a pointer to the first element: string *p2 = nums; //equivalent to p2 = &nums [0] Note In most expressions, when we use an object of array type, we are really using a pointer to the first element in that array.. There are various implications of the fact that operations on arrays are often really operations on pointers. One such implication is that when we use an array as an initializer for a variable defined using auto ($ 2.5.2, p. 68), the deduced type is a pointer, not an array: intia[]={01,2,3,4,5,6,7,8,9};//iaisanarrayoften ints auto ia2 (ia) ; // ia2 is an int that points to the first element in ia ia2=42; // error: ia2 is a pointer, and we can't assign an int to a pointer Although ia is an array of ten ints, when we use ia as an initializer, the compiler treats that initialization as if we had written.","Strings, Vectors, and Arrays"
Exercise 3.34,"Given that p1 and p2 point to elements in the same array, what does the following code do? Are there values of p1 or p2 that make this code illegal? p1 += p2 - pl;","Strings, Vectors, and Arrays"
Exercise 3.35,"Using pointers, write a program to set the elements in an array to zero.","Strings, Vectors, and Arrays"
Exercise 3.36,Write a program to compare two arrays for equality. Write a similar program to compare two vectors.,"Strings, Vectors, and Arrays"
Exercise 3.37,"What does the following program do? const char ca[] ={'h','e','l','l','o'}; const char *cp = ca; while *cp) cout << *cp << endl; ++ Cp ; )","Strings, Vectors, and Arrays"
Exercise 3.38,"In this section, we noted that it was not only illegal but meaningless to. try to add two pointers. Why would adding two pointers be meaningless?","Strings, Vectors, and Arrays"
Exercise 3.39,Write a program to compare two strings. Now write a program to. compare the values of two C-style character strings.,"Strings, Vectors, and Arrays"
Exercise 3.40,"Write a program to define two character arrays initialized from string literals. Now define a third character array to hold the concatenation of the two arrays. Use strcpy and strcat to copy the two arrays into the third. 3.5.5Interfacing to Older Code. Many C++ programs predate the standard library and do not use the st ring and vector types. Moreover, many C++ programs interface to programs written in C or other languages that cannot use the C++ library. Hence, programs written in modern C++ may have to interface to code that uses arrays and/or C-style charac- ter strings. The C++ library offers facilities to make the interface easier to manage. Mixing Library strings and C-Style Strings In S 3.2.1 (p. 84) we saw that we can initialize a st ring from a string literal: string s(""Hello World""); // sholds Hello World More generally, we can use a null-terminated character array anywhere that we can use a string literal: We can use a null-terminated character array to initialize or assign a st ring. We can use a null-terminated character array as one operand (but not both operands) to the string addition operator or as the right-hand operand in the string compound assignment (+=) operator. The reverse functionality is not provided: There is no direct way to use a library. st ring when a C-style string is required. For example, there is no way to initialize a character pointer from a string. There is, however, a string member function named c str that we can often use to accomplish what we want: char +str = s; // error:cant initializea char+froma string const char *str = s.c_str);// ok","Strings, Vectors, and Arrays"
Exercise 3.41,Write a program to initialize a vector from an array of ints..,"Strings, Vectors, and Arrays"
Exercise 3.42,"Write a program to copy a vector of ints into an array of ints. be helpful to keep this fact in mind when you use what appears to be a multidi- mensional array. We define an array whose elements are arrays by providing two dimensions: the dimension of the array itself and the dimension of its elements:. int ia [3] [4] ; //array of size 3; each element is an array of ints of size 4 / /array of size 10; each element is a 20-element array whose elements are arrays of 30 ints int arr [10] [20] [30] ={0}; // initializeall elements to 0 As we saw in $ 3.5.1 (p. 115), we can more easily understand these definitions by reading them from the inside out. We start with the name we're defining (ia) and see that ia is an array of size 3. Continuing to look to the right, we see that the elements of ia also have a dimension. Thus, the elements in ia are themselves arrays of size 4. Looking left, we see that the type of those elements is int. So, ia is an array of size 3, each of whose elements is an array of four ints.. We read the definition for arr in the same way. First we see that arr is an array of size 10. The elements of that array are themselves arrays of size 20. Each of those arrays has 30 elements that are of type int. There is no limit on how many subscripts are used. That is, we can have an array whose elements are arrays of elements that are arrays, and so on. In a two-dimensional array, the first dimension is usually referred to as the row and the second as the column. Initializing the Elements of a Multidimensional Array As with any array, we can initialize the elements of a multidimensional array by providing a bracketed list of initializers. Multidimensional arrays may be initial-. ized by specifying bracketed values for each row: int ia[3] [4] = { I Ithree elements; each element is an array of size 4 {0123} //initializers for the row indexed by 0 {45,6,7} //initializers for the row indexed by 1 {89,10,11}//initializers for the row indexed by2 1{ The nested braces are optional. The following initialization is equivalent, although considerably less clear: / /equivalent initialization without the optional nested braces for each rou. intia[3][4]={0,1,2,3,4,5,6,7,8,9,10,11}; As is the case for single-dimension arrays, elements may be left out of the ini tializer list. We can initialize only the first element of each row as follows:.","Strings, Vectors, and Arrays"
Exercise 3.43,"Write three different versions of a program to print the elements of ia. One version should use a range f or to manage the iteration, the other two should use an ordinary for loop in one case using subscripts and in the other using pointers. In. all three programs write all the types directly. That is, do not use a type alias, auto, or dec1type to simplify the code.","Strings, Vectors, and Arrays"
Exercise 3.44,Rewrite the programs from the previous exercises using a type alias for the type of the loop control variables..,"Strings, Vectors, and Arrays"
Exercise 3.45,"Rewrite the programs again, this time using auto.","Strings, Vectors, and Arrays"
Exercise 4.1,What is the value returned by 5 + 10  20/2?,Expressions
Exercise 4.2,"Using Table 4.12 (p. 166), parenthesize the following expressions to indi- cate the order in which the operands are grouped: (a) * vec.begin() b * vec.begin) + 1 4.1.3Order of Evaluation Precedence specifies how the operands are grouped. It says nothing about the order in which the operands are evaluated. In most cases, the order is largely unspecified. In the following expression inti=fl( * f2; we know that f1 and f2 must be called before the multiplication can be done. Af- ter all, it is their results that are multiplied. However, we have no way of knowing. whether f1 will be called before f2 or vice versa.",Expressions
Exercise 4.3,Order of evaluation for most of the binary operators is left undefined to give the compiler opportunities for optimization. This strategy presents a trade-off between efficient code generation and potential pitfalls in the use of the language by the programmer. Do you consider that an acceptable trade-off? Why or why not?,Expressions
Exercise 4.4,Parenthesize the following expression to show how it is evaluated. Test your answer by compiling the expression (without parentheses) and printing its result. 12/3+4+5+15+24%4/2,Expressions
Exercise 4.5,Determine the result of the following expressions. a-30+3+21/5 b-30+321/5 c30/3*21%5 d-30/321 %4,Expressions
Exercise 4.6,Write an expression to determine whether an int value is even or odd.,Expressions
Exercise 4.7,What does overflow mean? Show three expressions that will overflow. 4.3 Logical and Relational Operators The relational operators take operands of arithmetic or pointer type; the logical op erators take operands of any type that can be converted to bool. These operators all return values of type bool. Arithmetic and pointer operand(s) with a value of zero are false; all other values are true. The operands to these operators are rvalues and the result is an rvalue..,Expressions
Exercise 4.8,"Explain when operands are evaluated in the logical AND, logical OR, and equality operators.",Expressions
Exercise 4.9,"Explain the behavior of the condition in the following i f: const char *cp = ""Hello World""; if cp && *cp)",Expressions
Exercise 4.10,Write the condition for a whi1e loop that would read ints from the standard input and stop when the value read is equal to 42.,Expressions
Exercise 4.11,"Write an expression that tests four values, a, b, c, and d, and ensures that a is greater than b, which is greater than c, which is greater than d.",Expressions
Exercise 4.12,"Assuming i, j, and k are all ints, explain what i ! = j < k means.. 4.4 Assignment Operators The left-hand operand of an assignment operator must be a modifiable lvalue. For example, given inti=0,j =0k=0;// initializations,not assignment const int ci = i; //initialization, not assignment",Expressions
Exercise 4.13,What are the values of i and d after each assignment? int i; double d; ad=i=3.5 bi=d=3.5,Expressions
Exercise 4.14,Explain what happens in each of the i f tests: if (42=i) if i=42) //...,Expressions
Exercise 4.15,The following assignment is illegal. Why? How would you correct it? double dval; int ival; int *pi; dval = ival =pi = 0;,Expressions
Exercise 4.16,"Although the following are legal, they probably do not behave as the programmer expects. Why? Rewrite the expressions as you think they should be. aif p = getPtr = 0) bif (i =1024) 4.5 Increment and Decrement Operators The increment (++) and decrement (- -) operators provide a convenient notational shorthand for adding or subtracting 1 from an object. This notation rises above",Expressions
Exercise 4.17,Explain the difference between prefix and postfix increment.,Expressions
Exercise 4.18,What would happen if the whi1e loop on page 148 that prints the ele- ments from a vector used the prefix increment operator?,Expressions
Exercise 4.19,"Given that ptr points to an int, that vec is a vector<int >, and that ival is an int, explain the behavior of each of these expressions. Which, if any, are likely to be incorrect? Why? How might each be corrected? aptr =0 && *ptr++ (b ival++ && ival c) vec[ival++] <= vec[ival] 4.6 The Member Access Operators The dot (S 1.5.2, p. 23) and arrow (S 3.4.1, p. 110) operators provide for member access. The dot operator fetches a member from an object of class type; arrow is defined so that ptr- >mem is a synonym for (*ptr) . mem: string sl = ""a string, *p = &sl; auto n = sl.size(); // runthe sizememberofthe stringsl n=*p.size; // run si ze on the object to which p points n=p->size); // equivalentto (+p).size() Because dereference has a lower precedence than dot, we must parenthesize the dereference subexpression. If we omit the parentheses, this code means something quite different: I/run the si ze member of p, then dereference the result! *p.size(); I/ error: p is a pointer and has no member named si ze. This expression attempts to fetch the si ze member of the object p. However, p is a pointer, which has no members; this code will not compile. The arrow operator requires a pointer operand and yields an lvalue. The dot. operator yields an lvalue if the object from which the member is fetched is an lvalue; otherwise the result is an rvalue. EXERCISES SECTION 4.6",Expressions
Exercise 4.20,"Assuming that iter is a vector<string>::iterator, indicate which, if any, of the following expressions are legal. Explain the behavior of the le- gal expressions and why those that arent legal are in error. a*iter++; b *iter++; c*iter.empty (d) iter->empty(); (e) ++*iter; (f) iter++->empty();",Expressions
Exercise 4.21,Write a program to use a conditional operator to find the elements in a vector<int > that have odd value and double the value of each such element..,Expressions
Exercise 4.22,"Extend the program that assigned high pass, pass, and fail grades to also assign low pass for grades between 60 and 75 inclusive. Write two versions: One version that uses only conditional operators; the other should use one or more if statements. Which version do you think is easier to understand and why?",Expressions
Exercise 4.23,"The following expression fails to compile due to operator precedence.. Using Table 4.12 (p. 166), explain why it fails. How would you fix it?. string s = ""word""; string pl=s + s[s.size-1] =='s'? :""s;",Expressions
Exercise 4.24,"Our program that distinguished between high pass, pass, and fail de- pended on the fact that the conditional operator is right associative. Describe how that operator would be evaluated if the operator were left associative.. 4.8 The Bitwise Operators The bitwise operators take operands of integral type that they use as a collection of bits. These operators let us test and set individual bits. As well see in $ 17.2 (p. 723), we can also use these operators on a library type named bitset that represents a flexibly sized collection of bits. As usual, if an operand is a ""small integer,"" its value is first promoted ($ 4.11.1 p. 160) to a larger integral type. The operand(s) can be either signed or unsigned.",Expressions
Exercise 4.25,"What is the value of ~' q' << 6 on a machine with 32-bit ints and 8 bit chars, that uses Latin-1 character set in which ' q' has the bit pattern 01110 001?",Expressions
Exercise 4.26,"In our grading example in this section, what would happen if we used unsigned int as the type for quiz1?",Expressions
Exercise 4.27,"What is the result of each of these expressions? unsigned long ul1 = 3, ul2 = 7; (a) ul1 & ul2 (b) ul1  ul2 (c) ul1 && ul2 (p) ul1  ul2 4.9 The sizeof Operator. The si zeof operator returns the size, in bytes, of an expression or a type name. The operator is right associative. The result of si zeof is a constant expression S 2.4.4,p.65 of type size_t S 3.5.2,p.116).The operator takes one of two forms: sizeof (type) sizeof expr In the second form, si zeof returns the size of the type returned by the given ex pression. The si zeof operator is unusual in that it does not evaluate its operand:",Expressions
Exercise 4.28,Write a program to print the size of each of the built-in types..,Expressions
Exercise 4.29,"Predict the output of the following code and explain your reasoning Now run the program. Is the output what you expected? If not, figure out why. int x[10]; int *p=x; cout << sizeof(x)/sizeof(*x) << endl; cout << sizeof(p)/sizeof(*p) << endl;",Expressions
Exercise 4.30,"Using Table 4.12 (p. 166), parenthesize the following expressions to match the default evaluation: a sizeof x+y b) sizeof p->mem[i] c sizeof a <b (d) sizeof f() The left-hand expression is evaluated and its result is discarded. The result of a comma expression is the value of its right-hand expression. The result is an lvalue if the right-hand operand is an lvalue. One common use for the comma operator is in a for loop:. vector<int>::size_type cnt = ivec.size(); // assign values from size...1 to the elements in i vec. for(vector<int>::size_type ix = 0; ix = ivec.size(); ++ix, --cnt) ivec[ix] = cnt; This loop increments ix and decrements cnt in the expression in the for header. Both ix and cnt are changed on each trip through the loop. As long as the test of ix succeeds, we reset the current element to the current value of cnt.. EXERCISES SECTION 4.10",Expressions
Exercise 4.31,The program in this section used the prefix increment and decrement operators. Explain why we used prefix and not postfix. What changes would have to be made to use the postfix versions? Rewrite the program using postfix operators.,Expressions
Exercise 4.32,"Explain the following loop. constexpr int size = 5; int ia[size]={1,2,3,4,5}; for (int *ptr = ia, ix = 0; ix != size && ptr != ia+size; ++ix,++ptr{/+..*/}",Expressions
Exercise 4.33,"Using Table 4.12 (p. 166) explain what the following expression does: someValue ? ++x, ++y : --x,--y",Expressions
Exercise 4.34,"Given the variable definitions in this section, explain what conversions take place in the following expressions: a if fval)b) dval = fval + ival;c) dval + ival * cval; Remember that you may need to consider the associativity of the operators.",Expressions
Exercise 4.35,"Given the following definitions, char cval; int ival; unsigned int ui; float fval; double dval; identify the implicit type conversions, if any, taking place: a cval ='a+3; b fval =ui -ival * 1.0 c dval = ui  fval; (d) cval = ival + fval + dval; 4.11.2 Other Implicit Conversions In addition to the arithmetic conversions, there are several additional kinds of im- plicit conversions. These include: Array to Pointer Conversions: In most expressions, when we use an array, the array is automatically converted to a pointer to the first element in that array: int ia[10]; //array of ten ints int+ ip = ia; // convert ia to a pointer to the first element This conversion is not performed when an array is used with dec1type or as the operand of the address-of (&), si zeof, or typeid (which well cover in  19.2.2 (p. 826)) operators. The conversion is also omitted when we initialize a reference to an array (S 3.5.1, p. 114). As well see in  6.7 (p. 247), a similar pointer conversion happens when we use a function type in an expression. Pointer Conversions: There are several other pointer conversions: A constant in- tegral value of 0 and the literal nu11pt r can be converted to any pointer type; a pointer to any nonconst type can be converted to void*, and a pointer to any",Expressions
Exercise 4.36,"Assuming i is an int and d is a double write the expression i *= d so that it does integral, rather than floating-point, multiplication..",Expressions
Exercise 4.37,Rewrite each of the following old-style casts to use a named cast int i; double d; const string *ps; char *pc; void *pv; apv=voidps bi=int*pc; cpv=&d dpc = charpv;,Expressions
Exercise 4.38,Explain the following expression: double slope = static_cast<double>(j/i) ;,Expressions
Exercise 5.1,What is a null statement? When might you use a null statement?,Statements
Exercise 5.2,What is a block? When might you might use a block?,Statements
Exercise 5.3,"Use the comma operator ($ 4.10, p. 157) to rewrite the whi1e loop from S 1.4.1 (p. 11) so that it no longer requires a block. Explain whether this rewrite im- proves or diminishes the readability of this code. 5.2 Statement Scope We can define variables inside the control structure of the i f, swit ch, whi le, and for statements. Variables defined in the control structure are visible only within that statement and are out of scope after the statement ends: while (int i = get _num ()) // i is created and initialized on each iteration cout << i << endl; i = 0;//error: i is not accessible outside the loop If we need access to the control variable, then that variable must be defined outside. the statement: //find the first negative element. auto beg = v.begin(); while beg != v.end() && *beg >= 0) ++beg; if beg == v.end() I I we know that all elements in v are greater than or equal to zerc The value of an object defined in a control structure is used by that structure Therefore, such variables must be initialized. EXERCISES SECTION 5.2",Statements
Exercise 5.4,"Explain each of the following examples, and correct any problems you detect. a while string::iterator iter != s.end()) {/*...*/} bwhile bool status = find(word)) /*... */} if !status{/*...*/} 5.3 Conditional Statements C++ provides two statements that allow for conditional execution. The if state- ment determines the flow of control based on a condition. The swit ch statement evaluates an integral expression and chooses one of several execution paths based on the expression's value.",Statements
Exercise 5.5,"Using an i f-e1 se statement, write your own version of the program to generate the letter grade from a numeric grade.",Statements
Exercise 5.6,"Rewrite your grading program to use the conditional operator (S 4.7, p. 151) in place of the i fe1se statement.",Statements
Exercise 5.7,"Correct the errors in each of the following code fragments: a if (ivall != ival2) ivall = ival2 else ivall = ival2 = 0; b) if (ival < minval) minval = ival; occurs = 1; (c) if (int ival = get_value()) cout << ""ival = << ival << endl; if (!ival) cout <<""ival =O\n; d if ival = 0 ival = get_value();",Statements
Exercise 5.8,"What is a dangling el se? How are else clauses resolved in C++? 5.3.2 The switch Statement. A swi tch statement provides a convenient way of selecting among a (possibly large) number of fixed alternatives. As one example, suppose that we want to count how often each of the five vowels appears in some segment of text. Our program logic is as follows: Read every character in the input. Compare each character to the set of vowels. If the character matches one of the vowels, add 1 to that vowel's count. Display the results. For example, when we run the program on the text of this chapter, the output is Number of vowel a: 3195 Number of vowel e: 6230 Number of vowel i: 3102 Number of vowel o: 3289 Number of vowel u: 1033",Statements
Exercise 5.9,Write a program using a series of i f statements to count the number of vowels in text read from cin..,Statements
Exercise 5.10,"There is one problem with our vowel-counting program as we've im- plemented it: It doesn't count capital letters as vowels. Write a program that counts both lower- and uppercase letters as the appropriate vowelthat is, your program should count both ' a' and 'A' as part of aCnt, and so forth.",Statements
Exercise 5.11,"Modify our vowel-counting program so that it also counts the number of blank spaces, tabs, and newlines read.",Statements
Exercise 5.12,"Modify our vowel-counting program so that it counts the number of occurrences of the following two-character sequences: f f, f1, and fi..",Statements
Exercise 5.13,"Each of the programs in the highlighted text on page 184 contains a common programming error. Identify and correct each error. 5.4 Iterative Statements Iterative statements, commonly called loops, provide for repeated execution un- til a condition is true. The while and for statements test the condition before executing the body. The do whi1e executes the body and then tests its condition. 5.4.1 The whi1e Statement A whi1e statement repeatedly executes a target statement as long as a condition is true. Its syntactic form is. while (condition) statement In a whi 1e, statement (which is often a block) is executed as long as condition eval uates as t rue. condition may not be empty. If the first evaluation of condition yields fal se, statement is not executed. The condition can be an expression or an initialized variable declaration (S 5.2 p.174). Ordinarily, the condition itself or the loop body must do something to change the value of the expression. Otherwise, the loop might never terminate. Note Variables defined in a whi1e condition or whi1e body are created and destroyed on each iteration.. Using a while Loop A whi 1e loop is generally used when we want to iterate indefinitely, such as when. we read input. A whi 1e is also useful when we want access to the value of the loop control variable after the loop finishes. For example:",Statements
Exercise 5.14,"Write a program to read strings from standard input looking for du- plicated words. The program should find places in the input where one word is fol-. lowed immediately by itself. Keep track of the largest number of times a single repeti-. tion occurs and which word is repeated. Print the maximum number of duplicates, or. else print a message saying that no word was repeated. For example, if the input is. how now now now brown cow cow the output should indicate that the word now occurred three times. 5.4.2   Traditional for Statement The syntactic form of the for statement is:. for (init-statement condition; expression) statement The for and the part inside the parentheses is often referred to as the for header init-statement must be a declaration statement, an expression statement, or a null statement. Each of these statements ends with a semicolon, so the syntactic form can also be thought of as for (initializer; condition; expression) statement In general, init-statement is used to initialize or assign a starting value that is. modified over the course of the loop. condition serves as the loop control. As long as condition evaluates as true, statement is executed. If the first evaluation",Statements
Exercise 5.15,"Explain each of the following loops. Correct any problems you detect. a for int ix=0; ix != sz++ix {/+..*} if ix!=sz) //... b int ix {/*/}x++zs=xto c for int ix=0 ix != sz ++ix,++ sz{/*..*/}",Statements
Exercise 5.16,"The whi 1e loop is particularly good at executing while some condition holds; for example, when we need to read values until end-of-file. The for loop is generally thought of as a step loop: An index steps through a range of values in a collection. Write an idiomatic use of each loop and then rewrite each using the other loop construct. If you could use only one loop, which would you choose? Why?",Statements
Exercise 5.17,"Given two vectors of ints, write a program to determine whether one vector is a prefix of the other. For vectors of unequal length, compare the num ber of elements of the smaller vector. For example, given the vectors containing 0, 1, 1, and 2 and 0, 1, 1, 2, 3, 5, 8, respectively your program should return true. types match is to use the auto type specifier ($ 2.5.2, p. 68). That way the compiler will deduce the type for us. If we want to write to the elements in the sequence, the loop variable must be a reference type. On each iteration, the control variable is defined and initialized by the next value in the sequence, after which statement is executed. As usual, statement can be a single statement or a block. Execution ends once all the elements have been processed. We have already seen several such loops, but for completeness, here is one that doubles the value of each element in a vector:. vector<int>v={01,2,3,4,5,6,7,8,9}; I /range variable must be a reference so we can write to the elements. for auto &r : v) //for each element in v r*=2 1/double the value of each element in v The for header declares the loop control variable, r, and associates it with v. We use auto to let the compiler infer the correct type for r. Because we want to change the value of the elements in v, we declare r as a reference. When we assign to r inside the loop, that assignment changes the element to which r is bound A range for is defined in terms of the equivalent traditional for:. for (auto beg = v.begin(), end = v.end(); beg != end; ++beg) { auto &r = +beg; // r must be a reference so we can change the element r *=2; / /double the value of each element in v Now that we know how a range for works, we can understand why we said in S 3.3.2 (p. 101) that we cannot use a range for to add elements to a vector (or",Statements
Exercise 5.18,"Explain each of the following loops. Correct any problems you detect ado int vl, v2; cout << ""please enter two numbers to sum:"" ; if cin >> vl >> v2) cout << ""Sum is << vl +v2 << endl; while (cin); bdo{ //. }while int ival = get response()); c do int ival = get_response(); } while (ival);",Statements
Exercise 5.19,"Write a program that uses a do whi le loop to repetitively request two. strings from the user and report which string is less than the other. 5.5Jump Statements Jump statements interrupt the flow of execution. C++ offers four jumps: break, cont inue, and goto, which we cover in this chapter, and the return statement, which well describe in $ 6.3 (p. 222) 5.5.1 The break Statement A break statement terminates the nearest enclosing while, do while, for, or. switch statement. Execution resumes at the statement immediately following the terminated statement. A break can appear only within an iteration statement or switch statement.. (including inside statements or blocks nested inside such loops). A break affects only the nearest enclosing loop or swi t ch: string buf; while cin >> buf && !buf.empty)){ switch(buf [0]){ case '': /process up to the first blank for (auto it = buf.begin()+l; it != buf.end(); ++it) { if it==) break;//#1, leaves the for loop //... { J/break #1 transfers control here //remaining processing: break; // #2, leaves the switch statement",Statements
Exercise 5.20,"Write a program to read a sequence of st rings from the standard input until either the same word occurs twice in succession or all the words have been read. Use a while loop to read the text one word at a time. Use the break statement to terminate the loop if a word occurs twice in succession. Print the word if it occurs twice in succession, or else print a message saying that no word was repeated. 5.5.2 The continue Statement A continue statement terminates the current iteration of the nearest enclosing loop and immediately begins the next iteration. A cont inue can appear only in- side a for, whi 1e, or do whi le loop, including inside statements or blocks nested inside such loops. Like the break statement, a cont inue inside a nested loop af-. fects only the nearest enclosing loop. Unlike a break, a continue may appear inside a swi t ch only if that swit ch is embedded inside an iterative statement A cont inue interrupts the current iteration; execution stays inside the loop In the case of a while or a do whi1e, execution continues by evaluating the con- dition. In a traditional for loop, execution continues at the expression inside the for header. In a range for, execution continues by initializing the control variable from the next element in the sequence. For example, the following loop reads the standard input one word at a time Only words that begin with an underscore will be processed. For any other value, we terminate the current iteration and get the next input: string buf; while (cin >> buf && !buf.empty) if buf[0] =) continue; // get another input I/ still here? the input starts with an underscore; process buf ...",Statements
Exercise 5.21,"Revise the program from the exercise in  5.5.1 (p. 191) so that it looks only for duplicated words that start with an uppercase letter. 5.5.3 The goto Statement A goto statement provides an unconditional jump from the goto to a another statement in the same function. Best Programs should not use gotos. gotos make programs hard to under Praetices stand and hard to modify. The syntactic form of a goto statement is goto label; where label is an identifier that identifies a statement. A labeled statement is any statement that is preceded by an identifier followed by a colon:. end: return;//labeled statement; may be the target of a goto Label identifiers are independent of names used for variables and other identifiers. Hence, a label may have the same identifier as another entity in the program with-. out interfering with the other uses of that identifier. The goto and the labeled. statement to which it transfers control must be in the same function.. As with a swi t ch statement, a goto cannot transfer control from a point where an initialized variable is out of scope to a point where that variable is in scope: goto end; int ix = 10; // error: goto bypasses an initialized variable definition end: error: code here could use ix but the goto bypassed its declaration ix=42 A jump backward over an already executed definition is okay. Jumping back to a point before a variable is defined destroys the variable and constructs it again:. / /backward jump over an initialized variable definition is okay begin: int sz = get_size(); if sz <=0{ goto begin; } Here sz is destroyed when the goto executes. It is defined and initialized anew. when control passes back through its definition after the jump back to begin.",Statements
Exercise 5.22,"The last example in this section that jumped back to begin could be better written using a loop. Rewrite the code to eliminate the goto. 5.6 try Blocks and Exception Handling Exceptions are run-time anomalies-such as losing a database connection or en countering unexpected input-that exist outside the normal functioning of a pro- gram. Dealing with anomalous behavior can be one of the most difficult parts of designing any system. Exception handling is generally used when one part of a program detects a problem that it cannot resolve and the problem is such that the detecting part of the program cannot continue. In such cases, the detecting part needs a way to signal that something happened and that it cannot continue. Moreover, the detecting part needs a way to signal the problem without knowing what part of the program will deal with the exceptional condition. Having signaled what happened, the detecting part stops processing. A program that contains code that might raise an exception (usually) has an- other part to handle whatever happened. For example, if the problem is invalid in- put, the handling part might ask the user to provide correct input. If the database was lost, the handling part might alert an operator. dling parts of a program. In C++, exception handling involves .throw expressions, which the detecting part uses to indicate that it encoun tered something it can't handle. We say that a throw raises an exception. . try blocks, which the handling part uses to deal with an exception. A try block starts with the keyword try and ends with one or more catch clauses.. Exceptions thrown from code executed inside a try block are usually han- cat ch clauses are also known as exception handlers.. . A set of exception classes that are used to pass information about what happened between a throw and an associated cat ch.. In the remainder of this section, well introduce these three components of excep tion handling. Well also have more to say about exceptions in  18.1 (p. 772). 5.6.1 A throw Expression The detecting part of a program uses a throw expression to raise an exception. A throw consists of the keyword throw followed by an expression. The type of the expression determines what kind of exception is thrown. A throw expression is usually followed by a semicolon, making it into an expression statement.",Statements
Exercise 5.23,Write a program that reads two integers from the standard input and prints the result of dividing the first number by the second.,Statements
Exercise 5.24,Revise your program to throw an exception if the second number is zero. Test your program with a zero input to see what happens on your system if you don't catch an exception.,Statements
Exercise 5.25,Revise your program from the previous exercise to use a try block to catch the exception. The catch clause should print a message to the user and ask them to supply a new number and repeat the code inside the try.,Statements
Exercise 6.1,What is the difference between a parameter and an argument?,Functions
Exercise 6.2,"Indicate which of the following functions are in error and why. Suggest how you might correct the problems.. aint f{ string s; //... return s; 3 bf2int i{/*...*/} c int calcint vl, int vl /*...*/ } (d) double square(double x) return x * x;",Functions
Exercise 6.3,Write and test your own version of fact.,Functions
Exercise 6.4,"Write a function that interacts with the user, asking for a number and generating the factorial of that number. Call this function from main..",Functions
Exercise 6.5,"Write a function to return the absolute value of its argument. Objects defined outside any function exist throughout the program's execution Such objects are created when the program starts and are not destroyed until the. program ends. The lifetime of a local variable depends on how it is defined. Automatic Objects The objects that correspond to ordinary local variables are created when the func- tion's control path passes through the variable's definition. They are destroyed when control passes through the end of the block in which the variable is defined. Objects that exist only while a block is executing are known as automatic objects. After execution exits a block, the values of the automatic objects created in that block are undefined. Parameters are automatic objects. Storage for the parameters is allocated wher the function begins. Parameters are defined in the scope of the function body Hence they are destroyed when the function terminates. Automatic objects corresponding to the function's parameters are initialized by the arguments passed to the function. Automatic objects corresponding to local variables are initialized if their definition contains an initializer. Otherwise, they are default initialized ($ 2.2.1, p. 43), which means that uninitialized local variables of built-in type have undefined values.. Local static Objects It can be useful to have a local variable whose lifetime continues across calls to the function. We obtain such objects by defining a local variable as static. Each local static object is initialized before the first time execution passes through the",Functions
Exercise 6.6,"Explain the differences between a parameter, a local variable, and a local stat ic variable. Give an example of a function in which each might be useful.",Functions
Exercise 6.7,"Write a function that returns 0 when it is first called and then generates numbers in sequence each time it is called again.. 6.1.2Function Declarations Like any other name, the name of a function must be declared before we can use. it. As with variables ($ 2.2.2, p. 45), a function may be defined only once but may be declared multiple times. With one exception that well cover in S 15.3 (p. 603) we can declare a function that is not defined so long as we never use that function A function declaration is just like a function definition except that a declaration has no function body. In a declaration, a semicolon replaces the function body Because a function declaration has no body, there is no need for parameter names. Hence, parameter names are often omitted in a declaration. Although parameter names are not required, they can be used to help users of the function understand what the function does:",Functions
Exercise 6.8,"Write a header file named Chapter6 .h that contains declarations for the functions you wrote for the exercises in $ 6.1 (p. 205) 6.1.3 Separate Compilation As our programs get more complicated, well want to store the various parts of the program in separate files. For example, we might store the functions we wrote for the exercises in $ 6.1 (p. 205) in one file and store code that uses these functions in other source files. To allow programs to be written in logical parts, C++ supports what is commonly known as separate compilation. Separate compilation lets us split our programs into several files, each of which can be compiled independently Compiling and Linking Multiple Source Files. As an example, assume that the definition of our fact function is in a file named fact . cc and its declaration is in a header file named Chapter6 . h. Our fact . cc file, like any file that uses these functions, will include the Chapter6 .h header. Well store a main function that calls fact in a second file named factMain. cc.",Functions
Exercise 6.9,"Write your own versions of the fact . cc and factMain. cc files. These files should include your Chapt er6 . h from the exercises in the previous section. Use. these files to understand how your compiler supports separate compilation. 6.2Argument Passing As we've seen, each time we call a function, its parameters are created and initial- ized by the arguments passed in the call. Note Parameter initialization works the same way as variable initialization.. As with any other variable, the type of a parameter determines the interaction between the parameter and its argument. If the parameter is a reference ($ 2.3.1, p. 50), then the parameter is bound to its argument. Otherwise, the argument's value is copied. When a parameter is a reference, we say that its corresponding argument is ""passed by reference"" or that the function is ""called by reference."" As with any other reference, a reference parameter is an alias for the object to which it is bound;. that is, the parameter is an alias for its corresponding argument.",Functions
Exercise 6.10,"Using pointers, write a function to swap the values of two ints. Test the function by calling it and printing the swapped values. 6.2.2 Passing Arguments by Reference Recall that operations on a reference are actually operations on the object to which. the reference refers (S 2.3.1, p. 50): intn=0i=42 int &r = n; I/r is bound to n (i.e., r is another name for n) r =42; //nis now42 r=i; 1/n now has the same value as i i=r; //i has the same value as n. Reference parameters exploit this behavior. They are often used to allow a function to change the value of one or more of its arguments.. As one example, we can rewrite our reset program from the previous section to take a reference instead of a pointer: / / function that takes a reference to an int and sets the given object to zero void reset (int &i)// i is just another name for the object passed to reset i = O;// changes the value of the object to which i refers { As with any other reference, a reference parameter is bound directly to the object from which it is initialized. When we call this version of reset, i will be bound to. whatever int object we pass. As with any reference, changes made to i are made to the object to which i refers. In this case, that object is the argument to reset. When we call this version of reset, we pass an object directly; there is no need to pass its address: int j=42; reset (j) ;// j is passed by reference; the value in j is changed cout <<j=<<j<< endl//printsj=0 In this call, the parameter i is just another name for j. Any use of i inside reset. is a use of j",Functions
Exercise 6.11,Write and test your own version of reset that takes a reference.,Functions
Exercise 6.12,Rewrite the program from exercise 6.10 in  6.2.1 (p. 210) to use refer ences instead of pointers to swap the value of two ints. Which version do you think would be easier to use and why?,Functions
Exercise 6.13,"Assuming T is the name of a type, explain the difference between a. function declared as void f (T) and void f (T&).",Functions
Exercise 6.14,Give an example of when a parameter should be a reference type. Give. an example of when a parameter should not be a reference.,Functions
Exercise 6.15,"Explain the rationale for the type of each of find_char's parameters In particular, why is s a reference to const but occurs is a plain reference? Why are. these parameters references, but the char parameter c is not? What would happen if. we made s a plain reference? What if we made occurs a reference to const? 6.2.3 const Parameters and Arguments When we use parameters that are const, it is important to remember the discus- sion of top-level const from $ 2.4.3 (p. 63). As we saw in that section, a top-level const is one that applies to the object itself: const int ci = 42; //we cannot change ci; const is top-level. int i = ci; //ok: when we copy ci, its top-level const is ignored int + const p = &i; I/const is top-level; we cant assign to p. *p=0; // ok: changes through p are allowed; i is now 0 Just as in any other initialization, when we copy an argument to initialize a param eter, top-level consts are ignored. As a result, top-level const on parameters are ignored. We can pass either a const or a nonconst object to a parameter that has a top-level const: void fcn(const int i) { /+ fcncan read but not write to i */ } We can call fcn passing it either a const int or a plain int. The fact that top level consts are ignored on a parameter has one possibly surprising implication:",Functions
Exercise 6.16,"The following function, although legal, is less useful than it might be Identify and correct the limitation on this function: bool is_emptystring& s) {return s.empty(); }",Functions
Exercise 6.17,"Write a function to determine whether a string contains any capital letters. Write a function to change a string to all lowercase. Do the parameters you used in these functions have the same type? If so, why? If not, why not?",Functions
Exercise 6.18,"Write declarations for each of the following functions. When you write these declarations, use the name of the function to indicate what the function does. (a) A function named compare that returns a bool and has two parameters that. are references to a class named matrix.. (b) A function named change_val that returns a vector<int > iterator and. takes two parameters: One is an int and the other is an iterator for a vector<int >.",Functions
Exercise 6.19,"Given the following declarations, determine which calls are legal and which are illegal. For those that are illegal, explain why. double calc(double); int count(const string &, char); int sum(vector<int>::iterator, vector<int>::iterator, int); vector<int> vec(10) ; acalc23.4,55.1;bcount""abcda,'a; ccalc(66; d sum(vec.begin(),vec.end(,3.8);",Functions
Exercise 6.20,"When should reference parameters be references to const? What hap- pens if we make a parameter a plain reference when it could be a reference to const? J /despite appearances, these three declarations of print are equivalent I/ each function has a single parameter of type const int * void print(const int*); void print(const int[l); I/ shows the intent that the function takes an array. void print (const int [1o]) ; // dimension for documentation purposes (at best) Regardless of appearances, these declarations are equivalent: Each declares a func- tion with a single parameter of type const int *. When the compiler checks a call to print, it checks only that the argument has type const int *: inti=0,j[2]={0,1}; print(&i); // ok:&iisint* print (j);// ok:j is converted to an int  that points to j [0] If we pass an array to pr int, that argument is automatically converted to a pointer to the first element in the array; the size of the array is irrelevant. As with any code that uses arrays, functions that take array parameters WARNING must ensure that all uses of the array stay within the array bounds.",Functions
Exercise 6.21,Write a function that takes an int and a pointer to an int and returns the larger of the int value or the value to which the pointer points. What type should you use for the pointer?,Functions
Exercise 6.22,Write a function to swap two int pointers.,Functions
Exercise 6.23,Write your own versions of each of the print functions presented in this section. Call each of these functions to print i and j defined as follows: inti=0j[2]={01};,Functions
Exercise 6.24,"Explain the behavior of the following function. If there are problems in the code, explain what they are and how you might fix them. void print(const int ia[10]) for (sizeti = 0; i !=10 ++i) cout << ia[i] << endl; } prog -d -o ofile datao Such command-line options are passed to main in two (optional) parameters: int main(int argc, char *argv[]) { ... } The second parameter, argv, is an array of pointers to C-style character strings. The first parameter, argc, passes the number of strings in that array. Because the second parameter is an array, we might alternatively define main as. int main(int argc, char **argv) { ... }. indicating that argv points to a char *. When arguments are passed to main, the first element in argv points either to the name of the program or to the empty string. Subsequent elements pass the arguments provided on the command line. The element just past the last pointer is guaranteed to be 0. Given the previous command line, argc would be 5, and argv would hold the following C-style character strings: argv [0] =""prog"";//or argv [0] might point to an empty string argv[1] =-d; argv[2]=-o; argv[3] = ""ofile""; argv[4] =""data0""; argv[5] = 0; When you use the arguments in argv, remember that the optional ar- guments begin in argv [1] ; argv [0] contains the program's name, not WARNING user input.",Functions
Exercise 6.25,Write a main function that takes two arguments. Concatenate the sup plied arguments and print the resulting string.,Functions
Exercise 6.26,"Write a program that accepts the options presented in this section. Print the values of the arguments passed to main. 6.2.6 Functions with Varying Parameters Sometimes we do not know in advance how many arguments we need to pass to a function. For example, we might want to write a routine to print error messages generated from our program. We'd like to use a single function to print these error messages in order to handle them in a uniform way. However, different calls to our error-printing function might pass different arguments, corresponding to different kinds of error messages. The new standard provides two primary ways to write a function that takes a varying number of arguments: If all the arguments have the same type, we can pass a library type named initializer_list. If the argument types vary, we can write a special kind of function, known as a variadic template, which we'll cover in S 16.4 (p.699 C++ also has a special parameter type, ellipsis, that can be used to pass a vary- ing number of arguments. Well look briefly at ellipsis parameters in this section. However, it is worth noting that this facility ordinarily should be used only in programs that need to interface to C functions. initializer list Parameters We can write a function that takes an unknown number of arguments of a single type by using an initializer list parameter. An initializer list is a library type that represents an array (S 3.5, p.113) of values of the specified type. This type is defined in the initializer 1ist header. The operations that initializer list provides are listed in Table 6.1. Table 6.1: Operations on initializer_1ists initializer_ list<T> lst; Default initialization; an empty list of elements of type T. initializer list<T> lst{a,b,c...}; 1st has as many elements as there are initializers; elements are copies of the corresponding initializers. Elements in the list are const. lst2(lst) Copying or assigning an initiali zer_list does not copy the elements 1st2 = 1st in the list. After the copy, the original and the copy share the elements. lst.size() Number of elements in the list.. 1st.begin() Returns a pointer to the first and one past the last element in 1st. lst.end()",Functions
Exercise 6.27,Write a function that takes an initializer_list<int> and pro duces the sum of the elements in the list.,Functions
Exercise 6.28,"In the second version of error_msg that has an ErrCode parameter,. what is the type of elem in the for loop?",Functions
Exercise 6.29,"When you use an initiali zer_list in a range for would you ever use a reference as the loop control variable? If so, why? If not, why not? 6.3 Return Types and the return Statement. A return statement terminates the function that is currently executing and re- turns control to the point from which the function was called. There are two forms of return statements: return; return expression;",Functions
Exercise 6.30,Compile the version of str_subrange as presented on page 223 to see. what your compiler does with the indicated errors.,Functions
Exercise 6.31,When is it valid to return a reference? A reference to const?.,Functions
Exercise 6.32,"Indicate whether the following function is legal. If so, explain what it does; if not, correct any errors and then explain it.. int &get(int *arry, int index) {return arry[index]; } int main(){ int ia[10]; for inti=0i !=10++i) get(ia, i) = i; }",Functions
Exercise 6.33,Write a recursive function to print the contents of a vector..,Functions
Exercise 6.34,What would happen if the stopping condition in factorial were. if val !=0,Functions
Exercise 6.35,"In the call to factoria1, why did we pass val - 1 rather than val -- ? 6.3.3 Returning a Pointer to an Array Because we cannot copy an array, a function cannot return an array. However, a. function can return a pointer or a reference to an array (S 3.5.1, p. 114). Unfor- tunately, the syntax used to define functions that return pointers or references to",Functions
Exercise 6.36,"Write the declaration for a function that returns a reference to an array. of ten strings, without using either a trailing return, dec1type, or a type alias..",Functions
Exercise 6.37,"Write three additional declarations for the function in the previous ex- ercise. One should use a type alias, one should use a trailing return, and the third. should use dec1type. Which form do you prefer and why?.",Functions
Exercise 6.38,"Revise the arrPtr function on to return a reference to the array.. 6.4 Overloaded Functions Functions that have the same name but different parameter lists and that appear in the same scope are overloaded. For example, in S 6.2.4 (p. 214) we defined several functions named print: void print(const char *cp); void print(const int *beg, const int *end);. void print(const int ia[l, size_t size);",Functions
Exercise 6.39,"Explain the effect of the second declaration in each one of the following sets of declarations. Indicate which, if any, are illegal. a int calc(int, int); int calc(const int, const int); b int get; double get(); c) int *reset(int *); double *reset(double *); 6.4.1 Overloading and Scope Ordinarily, it is a bad idea to declare a function locally. However, to ex- plain how scope interacts with overloading, we will violate this practice. WARNINGE and use local function declarations. Programmers new to C++ are often confused about the interaction between scope and overloading. However, overloading has no special properties with respect to scope: As usual, if we declare a name in an inner scope, that name hides uses of that name declared in an outer scope. Names do not overload across scopes:.",Functions
Exercise 6.40,"Which, if either, of the following declarations are errors? Why? a int ff(int a, int b =0, int c = 0; b) char +init(int ht = 24, int wd, char bckgrnd);",Functions
Exercise 6.41,"Which, if any, of the following calls are illegal? Why? Which, if any, are. legal but unlikely to match the programmer's intent? Why? char +init(int ht, int wd = 80, char bckgrnd =  '); a init binit(24,10; cinit14,;",Functions
Exercise 6.42,"Give the second parameter of make_plura1 (S 6.3.2, p. 224) a default argument of ' s'. Test your program by printing singular and plural versions of the words success and failure. 6.5.2 Inline and constexpr Functions In S 6.3.2 (p. 224) we wrote a small function that returned a reference to the shorter of its two string parameters. The benefits of defining a function for such a small operation include the following: . It is easier to read and understand a call to shorterString than it would be to read and understand the equivalent conditional expression. Using a function ensures uniform behavior. Each test is guaranteed to be done the same way. If we need to change the computation, it is easier to change the function than to find and change every occurrence of the equivalent expression. . The function can be reused rather than rewritten for other applications. There is, however, one potential drawback to making shorterString a func- tion: Calling a function is apt to be slower than evaluating the equivalent expres- sion. On most machines, a function call does a lot of work: Registers are saved before the call and restored after the return; arguments may be copied; and the program branches to a new location. inline Functions Avoid Function Call Overhead A function specified as inline (usually) is expanded ""in line' at each call. If shorterString were defined as inline, then this call.",Functions
Exercise 6.43,"Which one of the following declarations and definitions would you put in a header? In a source file? Explain why. (a) inline bool eq(const BigInt&, const BigInt&) {...} (b) void putValues(int *arr, int size);",Functions
Exercise 6.44,Rewrite the isShorter function from  6.2.2 (p. 211) to be inline.,Functions
Exercise 6.45,"Review the programs you've written for the earlier exercises and decide whether they should be defined as inl ine. If so, do so. If not, explain why they should not be inline.",Functions
Exercise 6.46,"Would it be possible to define isShorter as a constexpr? If so, do so. If not, explain why not. 6.5.3Aids for Debugging C++ programmers sometimes use a technique similar to header guards (S 2.6.3, p. 77) to conditionally execute debugging code. The idea is that the program will contain debugging code that is executed only while the program is being devel- oped. When the application is completed and ready to ship, the debugging code is turned off. This approach uses two preprocessor facilities: assert and NDEBUG.",Functions
Exercise 6.47,"Revise the program you wrote in the exercises in  6.3.2 (p. 228) that used recursion to print the contents of a vector to conditionally print information about its execution. For example, you might print the size of the vector on each call. Compile and run the program with debugging turned on and again with it turned off.",Functions
Exercise 6.48,"Explain what this loop does and whether it is a good use of assert: string s; while cin >> s && s != sought {}// empty body assert (cin); Determining the Candidate and Viable Functions The first step of function matching identifies the set of overloaded functions con- sidered for the call. The functions in this set are the candidate functions. A can didate function is a function with the same name as the called function and for which a declaration is visible at the point of the call. In this example, there are four candidate functions named f. The second step selects from the set of candidate functions those functions that can be called with the arguments in the given call. The selected functions are the vi- able functions. To be viable, a function must have the same number of parameters as there are arguments in the call, and the type of each argument must matchor be convertible to-the type of its corresponding parameter. We can eliminate two of our candidate functions based on the number of argu ments. The function that has no parameters and the one that has two int parame- ters are not viable for this call. Our call has only one argument, and these functions have zero and two parameters, respectively. The function that takes a single int and the function that takes two doubles might be viable. Either of these functions can be called with a single argument The function taking two doubles has a default argument, which means it can be called with a single argument. Note When a function has default arguments (S 6.5.1, p. 236), a call may ap- pear to have fewer arguments than it actually does. Having used the number of arguments to winnow the candidate functions, we next look at whether the argument types match those of the parameters. As with any call, an argument might match its parameter either because the types match exactly or because there is a conversion from the argument type to the type of the parameter. In this example, both of our remaining functions are viable: . f (int) is viable because a conversion exists that can convert the argument of type double to the parameter of type int. . f (double, double) is viable because a default argument is provided for the function's second parameter and its first parameter is of type double, which exactly matches the type of the argument in the call",Functions
Exercise 6.49,What is a candidate function? What is a viable function?,Functions
Exercise 6.50,"Given the declarations for f from page 242, list the viable functions, if any for each of the following calls. Indicate which function is the best match, or if the call is illegal whether there is no match or why the call is ambiguous. af2.5642bf42cf420df2.563.14",Functions
Exercise 6.51,"Write all four versions of f. Each function should print a distinguish- ing message. Check your answers for the previous exercise. If your answers were incorrect, study this section until you understand why your answers were wrong 6.6.1Argument Type Conversions In order to determine the best match, the compiler ranks the conversions that could be used to convert each argument to the type of its corresponding parameter. Con- versions are ranked as follows: 1. An exact match. An exact match happens when: . The argument and parameter types are identical. The argument is converted from an array or function type to the corre- sponding pointer type. ($ 6.7 (p. 247) covers function pointers.) A top-level const is added to or discarded from the argument. 2. Match through a const conversion (S 4.11.2, p. 162) 3. Match through a promotion (S 4.11.1, p. 160). 4. Match through an arithmetic (S 4.11.1, p. 159) or pointer conversion (S 4.11.2 p.161) 5. Match through a class-type conversion. (S 14.9 (p.579) covers these conver sions.)",Functions
Exercise 6.52,"Given the following declarations, void manip(int, int); double dobj; what is the rank ($ 6.6.1, p. 245) of each conversion in the following calls? amanip'a,z bmanip55.4,dobj);",Functions
Exercise 6.53,"Explain the effect of the second declaration in each one of the following sets of declarations. Indicate which, if any, are illegal. a int calc(int&, int&); int calc(const int&, const int&); (b) int calc(char*, char); int calc(const char*, const char*); (c) int calc(char*, char); int calc(char* const, char* const); 6.7Pointers to Functions A function pointer is just that-a pointer that denotes a function rather than an object. Like any other pointer, a function pointer points to a particular type. A function's type is determined by its return type and the types of its parameters The function's name is not part of its type. For example: //compares lengths of two strings bool lengthCompare(const string &, const string &); has type bool (const string&, const string&). To declare a pointer that can point at this function, we declare a pointer in place of the function name: // pf points to a function returning bool that takes two const string references bool (*pf)(const string &, const string &); // uninitialized Starting from the name we are declaring, we see that pf is preceded by a *, so pf is a pointer. To the right is a parameter list, which means that pf points to a function. Looking left, we find that the type the function returns is boo1. Thus, pf points to a function that has two const string& parameters and returns boo1",Functions
Exercise 6.54,"Write a declaration for a function that takes two int parameters and. returns an int, and declare a vect or whose elements have this function pointer type..",Functions
Exercise 6.55,"Write four functions that add, subtract, multiply, and divide two int. values. Store pointers to these functions in your vect or from the previous exercise.",Functions
Exercise 6.56,Call each element in the vect or and print their result..,Functions
Exercise 7.1,"Write a version of the transaction-processing program from $ 1.6 (p. 24) using the Sa1es_dat a class you defined for the exercises in $ 2.6.1 (p. 72) 7.1.2 Defining the Revised sales data Class Our revised class will have the same data members as the version we defined in S 2.6.1 (p.72): bookNo,a string representing the IsBN; units sold, an unsigned that says how many copies of the book were sold; and revenue, a doub1e representing the total revenue for those sales. As we've seen, our class will also have two member functions, combine and isbn. In addition, well give Sales data another member function to return the average price at which the books were sold. This function, which well name. avg_price, isn't intended for general use. It will be part of the implementation, not part of the interface. We define ($ 6.1, p. 202) and declare ($ 6.1.2, p. 206) member functions similarly to ordinary functions. Member functions must be declared inside the class. Mem- ber functions may be defined inside the class itself or outside the class body. Non- member functions that are part of the interface, such as add, read, and print, are declared and defined outside the class. With this knowledge, we're ready to write our revised version of Sal es_data: struct Sales_data { // new members: operations on Sales_data objects std::string isbn() const {return bookNo; } Sales_data& combine(const Sales_data&); double avg_price() const;",Classes
Exercise 7.2,Add the combine and isbn members to the Sales_data class you wrote for the exercises in  2.6.2 (p. 76),Classes
Exercise 7.3,Revise your transaction-processing program from  7.1.1 (p. 256) to use these members.,Classes
Exercise 7.4,Write a class named Person that represents the name and address of a person. Use a string to hold each of these elements. Subsequent exercises will. incrementally add features to this class.,Classes
Exercise 7.5,"Provide operations in your Person class to return the name and ad- dress. Should these functions be const? Explain your choice.. 7.1.3 Defining Nonmember Class-Related Functions Class authors often define auxiliary functions, such as our add, read, and print functions. Although such functions define operations that are conceptually part of the interface of the class, they are not part of the class itself. We define nonmember functions as we would any other function. As with any other function, we normally separate the declaration of the function from its",Classes
Exercise 7.6,"Define your own versions of the add, read, and print functions",Classes
Exercise 7.7,Rewrite the transaction-processing program you wrote for the exercises in  7.1.2 (p. 260) to use these new functions.,Classes
Exercise 7.8,Why does read define its Sales_data parameter as a plain reference and print define its parameter as a reference to const?.,Classes
Exercise 7.9,Add operations to read and print Person objects to the code you wrote for the exercises in $ 7.1.2 (p. 260).,Classes
Exercise 7.10,"What does the condition in the following i f statement do? if (read(read(cin, datal), data2)) 7.1.4Constructors Each class defines how objects of its type can be initialized. Classes control object initialization by defining one or more special member functions known as con- structors. The job of a constructor is to initialize the data members of a class object A constructor is run whenever an object of a class type is created. In this section, well introduce the basics of how to define a constructor. Con- structors are a surprisingly complex topic. Indeed, well have more to say about constructors in $ 7.5 (p. 288), S 15.7 (p. 622), and  18.1.3 (p. 777), and in Chapter 13 Constructors have the same name as the class.Unlike other functions, con- structors have no return type. Like other functions, constructors have a (possibly empty) parameter list and a (possibly empty) function body. A class can have multiple constructors. Like any other overloaded function (S 6.4, p.230), the con- structors must differ from each other in the number or types of their parameters Unlike other member functions, constructors may not be declared as const (S 7.1.2, p. 258). When we create a const object of a class type, the object does not assume its ""constness"" until after the constructor completes the object's initial ization. Thus, constructors can write to const objects during their construction. The Synthesized Default Constructor Our Sales_data class does not define any constructors, yet the programs we've written that use Sales data objects compile and run correctly. As an example the program on page 255 defined two objects:.",Classes
Exercise 7.11,Add constructors to your Sales_data class and write a program to use each of the constructors.,Classes
Exercise 7.12,Move the definition of the Sales_data constructor that takes an istream into the body of the Sales_data class.,Classes
Exercise 7.13,Rewrite the program from page 255 to use the istream constructor.,Classes
Exercise 7.14,Write a version of the default constructor that explicitly initializes the members to the values we have provided as in-class initializers.,Classes
Exercise 7.15,Add appropriate constructors to your Person class..,Classes
Exercise 7.16,"What, if any, are the constraints on where and how often an access spec- ifier may appear inside a class definition? What kinds of members should be defined after a public specifier? What kinds should be private?.",Classes
Exercise 7.17,"What, if any, are the differences between using class or struct?",Classes
Exercise 7.18,What is encapsulation? Why is it useful?,Classes
Exercise 7.19,"Indicate which members of your Person class you would declare as public and which you would declare as private. Explain your choice... 7.2.1 Friends Now that the data members of Sales_data are private, our read, print, and. add functions will no longer compile. The problem is that although these functions are part of the Sales data interface, they are not members of the class. A class can allow another class or function to access its nonpub1ic members by making that class or function a friend. A class makes a function its friend by including a declaration for that function preceded by the keyword friend: class Sales_data { J/friend declarations for nonmember Sales_dat a operations added. friend Sales_data add(const Sales_data&, const Sales_data&); friend std::istream &read(std::istream&, Sales_data&); friend std::ostream &print(std::ostream&, const Sales_data&); I/other members and access specifiers as before public: Sales_data() = default; Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {} Sales_data(const std::string &s): bookNo(s) {} Sales_data (std::istream&) ; std::string isbn() const { return bookNo; } Sales_data &combine(const Sales_data&); private: std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; } ;",Classes
Exercise 7.20,When are friends useful? Discuss the pros and cons of using friends,Classes
Exercise 7.21,Update your Sales_data class to hide its implementation. The pro- grams you've written to use Sales_data operations should still continue to work. Recompile those programs with your new class definition to verify that they still work.,Classes
Exercise 7.22,"Update your Person class to hide its implementation. 7.3Additional Class Features The Sales_data class is pretty simple, yet it allowed us to explore quite a bit of the language support for classes. In this section, well cover some additional class- related features that Sales_dat a doesn't need to use. These features include type members, in-class initializers for members of class type, mutab1e data members in1 ine member functions, returning * this from a member function, more about how we define and use class types, and class friendship 7.3.1Class Members Revisited To explore several of these additional features, well define a pair of cooperating classes named Screen and Window_mgr. Defining a Type Member A Screen represents a window on a display. Each Screen has a string member that holds the Screen's contents, and three string : : size type members that represent the position of the cursor, and the height and width of the screen. In addition to defining data and function members, a class can define its own local names for types. Type names defined by a class are subject to the same access controls as any other member and may be either public or private: class Screen { public: typedef std::string::size_type pos; private: pos cursor = 0; pos height = 0, width = 0; std::string contents; } ;",Classes
Exercise 7.23,Write your own version of the Screen class.,Classes
Exercise 7.24,"Give your Screen class three constructors: a default constructor; a con- structor that takes values for height and width and initializes the contents to hold the given number of blanks; and a constructor that takes values for height, width, and a character to use as the contents of the screen.",Classes
Exercise 7.25,"Can Screen safely rely on the default versions of copy and assign- ment? If so, why? If not, why not?",Classes
Exercise 7.26,"Define Sales_data: :avg price as an inline function. 7.3.2 Functions That Return *this Next well add functions to set the character at the cursor or at a given location: class Screen { public: Screen &set(char); Screen &set(pos, pos, char); //other members as before }; inline Screen &Screen::set(char c) contents [cursor] = c; / / set the new value at the current cursor location return *this; I/return this object as an lvalue ^ inline Screen &Screen::set(pos r, pos col, char ch) contents[r*width + col] = ch; I/set specified location to given value return *this; //return this object as an lvalue Like the move operation, our set members return a reference to the object on which they are called (S 7.1.2, p. 259). Functions that return a reference are lvalues (S 6.3.2, p. 226), which means that they return the object itself, not a copy of the object. If we concatenate a sequence of these actions into a single expression: I / move the cursor to a given position, and set that character myScreen.move(4,0).set('#'); these operations will execute on the same object. In this expression, we first move the cursor inside myScreen and then set a character in myScreen's contents member. That is, this statement is equivalent to myScreen.move (4, 0) ; myScreen.set('#'); Had we defined move and set to return Screen, rather than Screen&, this state- ment would execute quite differently. In this case it would be equivalent to:",Classes
Exercise 7.27,"Add the move, set, and display operations to your version of Screen. Test your class by executing the following code: Screen myScreen(5, 5,'X'); myScreen.move(4,0).set('#').display(cout); cout <""\n; myScreen.display(cout) ; cout <<""\n;",Classes
Exercise 7.28,"What would happen in the previous exercise if the return type of move, set, and display was Screen rather than Screen&?",Classes
Exercise 7.29,"Revise your Screen class so that move, set, and display functions return Screen and check your prediction from the previous exercise.",Classes
Exercise 7.30,"It is legal but redundant to refer to members through the this pointer. Discuss the pros and cons of explicitly using the thi s pointer to access members. struct First { int memi; int getMem(); }; struct Second { int memi; int getMem(); { First obj1; Second obj2 = obj1; // error:obj1 and obj2 have different types Even if two classes have exactly the same member list, they are different Note types. The members of each class are distinct from the members of any other class (or any other scope). We can refer to a class type directly, by using the class name as a type name. Alternatively, we can use the class name following the keyword class or st ruct: Sales data iteml; default-initialized object of type Sales data class Sales_data iteml; // equivalent declaration Both methods of referring to a class type are equivalent. The second method is inherited from C and is also valid in C++. Class Declarations Just as we can declare a function apart from its definition ($ 6.1.2, p. 206), we can also declare a class without defining it. class Screen; // declaration ofthe Screen class",Classes
Exercise 7.31,"Define a pair of classes X and Y, in which  has a pointer to Y, and Y has an object of type X 7.3.4Friendship Revisited Our Sales data class defined three ordinary nonmember functions as friends (S 7.2.1, p. 269). A class can also make another class its friend or it can declare specific member functions of another (previously defined) class as friends. In ad dition, a friend function can be defined inside the class body. Such functions are. implicitly inline. Friendship between Classes As an example of class friendship, our Window_mgr class (S 7.3.1, p. 274) will have members that will need access to the internal data of the Screen objects it. manages. For example, let's assume that we want to add a member, named clear",Classes
Exercise 7.32,"Define your own versions of Screen and Window_mgr in which clear is a member of window_mgr and a friend of Screen. 7.4Class Scope Every class defines its own new scope. Outside the class scope, ordinary data and function members may be accessed only through an object, a reference, or a pointer using a member access operator (S 4.6, p. 150). We access type members from the class using the scope operator . In either case, the name that follows the operator. must be a member of the associated class.. Screen::pos ht = 24, wd = 80; // use the pos type defined by Screen Screen scr(ht, wd, '); Screen *p = &scr; char c = scr.get () ; // fetches the get member from the object scr c =p->get(); I/fetches the get member from the object to which p points Scope and Members Defined outside the Class The fact that a class is a scope explains why we must provide the class name as well as the function name when we define a member function outside its class ($ 7.1.2 p. 259). Outside of the class, the names of the members are hidden. Once the class name is seen, the remainder of the definition-including the. parameter list and the function bodyis in the scope of the class. As a result, we can refer to other class members without qualification. For example, recall the c1ear member of class window mgr (S 7.3.4, p. 280) That function's parameter uses a type that is defined by Window_mgr: void Window_mgr::clear (ScreenIndex i). Screen &s = screens [i]; S.contents = string(s.height * s.width, ' '); A Because the compiler sees the parameter list after noting that we are in the scope of class window mgr, there is no need to specify that we want the ScreenIndex.",Classes
Exercise 7.33,"What would happen if we gave Screen a size member defined as follows? Fix any problems you identify.. pos Screen::size() const { return height * width;. } 7.4.1 Name Lookup and Class Scope. In the programs we've written so far, name lookup (the process of finding which declarations match the use of a name) has been relatively straightforward: First, look for a declaration of the name in the block in which the name was used. Only names declared before the use are considered If the name isnt found, look in the enclosing scope(s). If no declaration is found, then the program is in error.",Classes
Exercise 7.34,What would happen if we put the typedef of pos in the Screen class on page 285 as the last line in the class?,Classes
Exercise 7.35,"Explain the following code, indicating which definition of Type or initVal is used for each use of those names. Say how you would fix any errors. typedef string Type; Type initVal(); class Exercise { public: typedef double Type; Type setVal (Type); Type initVal(); private: int val; }; Type Exercise::setVal(Type parm) { val = parm + initVal(); return val; }",Classes
Exercise 7.36,"The following initializer is in error. Identify and fix the problem struct x{ X int i, int j): basei),rem(base %j) {} int rem, base; };",Classes
Exercise 7.37,"Using the version of Sales_data from this section, determine which constructor is used to initialize each of the following variables and list the values of the data members in each object: Sales_data first_item(cin); int main(){ Sales_data next;. Sales_data last (""9-999-99999-9""); {",Classes
Exercise 7.38,We might want to supply cin as a default argument to the constructor that takes an istream&. Write the constructor declaration that uses cin as a default argument.,Classes
Exercise 7.39,"Would it be legal for both the constructor that takes a string and the one that takes an istream& to have default arguments? If not, why not?",Classes
Exercise 7.40,"Choose one of the following abstractions (or an abstraction of your own choosing). Determine what data are needed in the class. Provide an appropriate set of constructors. Explain your decisions. a Book bDate (c) Employee (d) vehicle (e) Object (f) Tree 7.5.2Delegating Constructors The new standard extends the use of constructor initializers to let us define so- called delegating constructors. A delegating constructor uses another constructor from its own class to perform its initialization. It is said to delegate"" some (or all) of its work to this other constructor. Like any other constructor, a delegating constructor has a member initializer",Classes
Exercise 7.41,Rewrite your own version of the Sales_data class to use delegating constructors. Add a statement to the body of each of the constructors that prints a message whenever it is executed. Write declarations to construct a Sal es_data object in every way possible. Study the output until you are certain you understand the order. of execution among delegating constructors.,Classes
Exercise 7.42,"For the class you wrote for exercise 7.40 in S 7.5.1 (p.291), decide whether any of the constructors might use delegation. If so, write the delegating con- structor(s) for your class. If not, look at the list of abstractions and choose one that you think would use a delegating constructor. Write the class definition for that abstraction.",Classes
Exercise 7.43,"Assume we have a class named NoDef au1t that has a constructor that takes an int, but has no default constructor. Define a class c that has a member of type NoDefau1t. Define the default constructor for C.",Classes
Exercise 7.44,"Is the following declaration legal? If not, why not? vector<NoDefault> vec (10) ;",Classes
Exercise 7.45,What if we defined the vector in the previous execercise to hold ob- jects of type C?,Classes
Exercise 7.46,"Which, if any, of the following statements are untrue? Why? (a) A class must provide at least one constructor. (b) A default constructor is a constructor with an empty parameter list. (c) If there are no meaningful default values for a class, the class should not pro- vide a default constructor. (d) If a class does not define a default constructor, the compiler generates one that. initializes each data member to the default value of its associated type. 7.5.4Implicit Class-Type Conversions As we saw in $ 4.11 (p. 159), the language defines several automatic conversions among the built-in types. We also noted that classes can define implicit conversions as well. Every constructor that can be called with a single argument defines an implicit conversion to a class type. Such constructors are sometimes referred to as",Classes
Exercise 7.47,Explain whether the Sales_data constructor that takes a string. should be explicit. What are the benefits of making the constructor explicit?. What are the drawbacks?,Classes
Exercise 7.48,"Assuming the Sales_data constructors are not explicit, what op- erations happen during the following definitions string null_isbn(""9-999-99999-9""); Sales_data iteml (null_isbn);. Sales_data item2(*9-999-99999-9""); What happens if the Sales_data constructors are explicit?",Classes
Exercise 7.49,"For each of the three following declarations of combine, explain what happens if we call i. combine (s), where i is a Sales_data and s is a string. (a) Sales_data &combine(Sales_data); (b) Sales_data &combine(Sales_data&); (c) Sales_data &combine(const Sales_data&) const;",Classes
Exercise 7.50,Determine whether any of your Person class constructors should be explicit.,Classes
Exercise 7.51,"Why do you think vector defines its single-argument constructor as. explicit, but string does not?",Classes
Exercise 7.52,"Using our first version of Sa1es_data from  2.6.1 (p. 72), explain the. following initialization. Identify and fix any problems. Sales_data item ={""978-0590353403"", 25,15.99}; 7.5.6Literal Classes In S 6.5.2 (p. 239) we noted that the parameters and return type of a constexpr function must be literal types. In addition to the arithmetic types, references, and pointers, certain classes are also literal types. Unlike other classes, classes that are literal types may have function members that are constexpr. Such members must meet all the requirements of a cons t expr function. These member functions are implicitly const (S 7.1.2, p. 258) An aggregate class ($ 7.5.5, p. 298) whose data members are all of literal type is a literal class. A nonaggregate class, that meets the following restrictions, is also a literal class: The data members all must have literal type. The class must have at least one constexpr constructor. . If a data member has an in-class initializer, the initializer for a member of built-in type must be a constant expression (S 2.4.4, p.65), or if the mem- ber has class type, the initializer must use the member's own constexpr. constructor. . The class must use default definition for its destructor, which is the member that destroys objects of the class type (S 7.1.5, p. 267) constexpr Constructors Although constructors cant be const (S 7.1.4, p. 262), constructors in a literal class can be constexpr (S 6.5.2, p. 239) functions. Indeed, a literal class must provide at least one constexpr constructor. A constexpr constructor can be declared as = def ault ($ 7.1.4, p. 264) (or as a deleted function, which we cover in S 13.1.6 (p. 507). Otherwise, a constexpr constructor must meet the requirements of a constructormeaning it can have no return statement-and of a constexpr function-meaning the only executable statement it can have is a return statement ($ 6.5.2, p. 239). As a result, the body of a constexpr constructor is typically empty. We define a const expr constructor by preceding its declaration with the keyword constexpr: class Debug { public: constexpr Debug(bool b = true): hw(b), io(b), other(b) { } constexpr Debug(bool h, bool i, bool o): hwh),ioi),othero{}",Classes
Exercise 7.53,"Define your own version of Debug,",Classes
Exercise 7.54,"Should the members of Debug that begin with set_be declared as constexpr? If not, why not?",Classes
Exercise 7.55,"Is the Data class from  7.5.5 (p. 298) a literal class? If not, why not? If so, explain why it is literal. 7.6 static Class Members Classes sometimes need members that are associated with the class, rather than with individual objects of the class type. For example, a bank account class might need a data member to represent the current prime interest rate. In this case, we'd want to associate the rate with the class, not with each individual object. From an efficiency standpoint, there'd be no reason for each object to store the rate. Much more importantly, if the rate changes, we'd want each object to use the new value. Declaring static Members We say a member is associated with the class by adding the keyword static to its declaration. Like any other member, static members can be public or private. The type of a static data member can be const, reference, array, class type, and so forth",Classes
Exercise 7.56,What is a static class member? What are the advantages of static members? How do they differ from ordinary members?,Classes
Exercise 7.57,Write your own version of the Account class..,Classes
Exercise 7.58,"Which, if any, of the following stati c data member declarations and. definitions are errors? Explain why. //example.h class Example public: static double rate = 6.5; static const int vecsize = 20; static vector<double> vec(vecSize) ; }; //example.C #include ""example.h"" double Example::rate; vector<double> Example::vec;",Classes
Exercise 8.1,Write a function that takes and returns an istream&. The function should read the stream until it hits end-of-file. The function should print what it reads to the standard output. Reset the stream so that it is valid before returning the stream..,Streams and IO Library
Exercise 8.2,"Test your function by calling it, passing cin as an argument..",Streams and IO Library
Exercise 8.3,"What causes the following whi1e to terminate? while (cin >> i) /* ... * / 8.1.3Managing the Output Buffer Each output stream manages a buffer, which it uses to hold the data that the pro-. gram reads and writes. For example, when the following code is executed os << ""please enter a value: ""; the literal string might be printed immediately, or the operating system might store the data in a buffer to be printed later. Using a buffer allows the operating system. to combine several output operations from our program into a single system-level write. Because writing to a device can be time-consuming, letting the operating. system combine several output operations into a single write can provide an im-. portant performance boost. There are several conditions that cause the buffer to be flushed-that is, to be written-to the actual output device or file: The program completes normally. All output buffers are flushed as part of. the return from main. At some indeterminate time, the buffer can become full, in which case it will be flushed before writing the next value.. .We can flush the buffer explicitly using a manipulator such as end1 (S 1.2, p.7). We can use the unitbuf manipulator to set the stream's internal state to empty the buffer after each output operation. By default, unitbuf is set for cerr, so that writes to cerr are flushed immediately. An output stream might be tied to another stream. In this case, the output stream is flushed whenever the stream to which it is tied is read or written. By default, cin and cerr are both tied to cout. Hence, reading cin or writing to cerr flushes the buffer in cout..",Streams and IO Library
Exercise 8.4,"Write a function to open a file for input and read its contents into a vector of strings, storing each line as a separate element in the vector.",Streams and IO Library
Exercise 8.5,Rewrite the previous program to store each word in a separate element.,Streams and IO Library
Exercise 8.6,"Rewrite the bookstore program from S 7.1.1 (p. 256) to read its transac- tions from a file. Pass the name of the file as an argument to main ($ 6.2.5, p. 218). 8.2.2 File Modes Each stream has an associated file mode that represents how the file may be used Table 8.4 lists the file modes and their meanings.. Table 8.4: File Modes in Open for input out Open for output app Seek to the end before every write. ate Seek to the end immediately after the open. trunc Truncate the file binary Do IO operations in binary mode. We can supply a file mode whenever we open a file--either when we call oper or when we indirectly open the file when we initialize a stream from a file name. The modes that we can specify have the following restrictions: . out may be set only for an ofstream or fstream object . in may be set only for an ifstream or fstream object trunc may be set only when out is also specified.. . app mode may be specified so long as trunc is not. If app is specified, the file is always opened in output mode, even if out was not explicitly specified. By default, a file opened in out mode is truncated even if we do not specify trunc. To preserve the contents of a file opened with out, either we must. also specify app, in which case we can write only at the end of the file, or we must also specify in, in which case the file is open for both input and output (S 17.5.3 (p. 763) will cover using the same file for input and output) The ate and binary modes may be specified on any file stream object type and in combination with any other file modes.. Each file stream type defines a default file mode that is used whenever we do not otherwise specify a mode. Files associated with an ifstream are opened in in mode; files associated with an ofstream are opened in out mode; and files associated with an fstream are opened with both in and out modes..",Streams and IO Library
Exercise 8.7,Revise the bookstore program from the previous section to write its out- put to a file. Pass the name of that file as a second argument to main..,Streams and IO Library
Exercise 8.8,Revise the program from the previous exercise to append its output to its given file. Run the program on the same output file at least twice to ensure that the data are preserved.,Streams and IO Library
Exercise 8.9,Use the function you wrote for the first exercise in  8.1.2 (p. 314) to print. the contents of an istringstream object.,Streams and IO Library
Exercise 8.10,Write a program to store each line from a file in a vector<string>. Now use an istringst ream to read each element from the vector a word at a time..,Streams and IO Library
Exercise 8.11,"The program in this section defined its istringstream object inside. the outer while loop. What changes would you need to make if record were defined outside that loop? Rewrite the program, moving the definition of record outside the whi le, and see whether you thought of all the changes that are needed.",Streams and IO Library
Exercise 8.12,Why didnt we use in-class initializers in PersonInfo?,Streams and IO Library
Exercise 8.13,Rewrite the phone number program from this section to read from a named file rather than from cin.,Streams and IO Library
Exercise 8.14,Why did we declare entry and nums as const auto &?,Streams and IO Library
Exercise 9.1,"Which is the most appropriate- a vector, a deque, or a list-for the. following program tasks? Explain the rationale for your choice. If there is no reason to prefer one or another container, explain why not.. (a) Read a fixed number of words, inserting them in the container alphabetically as they are entered. Well see in the next chapter that associative containers are better suited to this problem. (b) Read an unknown number of words. Always insert new words at the back Remove the next value from the front.. (c) Read an unknown number of integers from a file. Sort the numbers and then print them to standard output. 9.2 Container Library Overview The operations on the container types form a kind of hierarchy: Some operations (Table 9.2 (p. 330)) are provided by all container types. Other operations are specific to the sequential (Table 9.3 (p. 335)), the asso- ciative (Table 11.7 (p. 438)), or the unordered (Table 11.8 (p. 445)) containers Still others are common to only a smaller subset of the containers.",Sequential Containers
Exercise 9.2,Define a 1i st that holds elements that are deques that hold ints.,Sequential Containers
Exercise 9.3,What are the constraints on the iterators that form iterator ranges?,Sequential Containers
Exercise 9.4,Write a function that takes a pair of iterators to a vector<int > and an. int value. Look for that value in the range and return a bool indicating whether it was found.,Sequential Containers
Exercise 9.5,Rewrite the previous program to return an iterator to the requested ele-. ment. Note that the program must handle the case where the element is not found.,Sequential Containers
Exercise 9.6,"What is wrong with the following program? How might you correct it? list<int> lstl; list<int>::iterator iterl = lstl.begin(), iter2 = lstl.end(); while (iterl < iter2) /* ... * / 9.2.2Container Type Members Each container defines several types, shown in Table 9.2 (p. 330). We have al- ready used three of these container-defined types: size_type (S 3.2.2, p. 88), iterator, and const_iterator ($3.4.1,p.108)",Sequential Containers
Exercise 9.7,What type should be used as the index into a vector of ints?,Sequential Containers
Exercise 9.8,"What type should be used to read elements in a 1ist of strings? To write them? 9.2.3 begin and end Members The begin and end operations ($ 3.4.1, p. 106) yield iterators that refer to the first and one past the last element in the container. These iterators are most often used to form an iterator range that encompasses all the elements in the container. As shown in Table 9.2 (p. 330), there are several versions of begin and end The versions with an r return reverse iterators (which we cover in  10.4.3 (p. 407)) Those that start with a c return the const version of the related iterator: list<string> a = {""Milton"", ""Shakespeare"", ""Austen""}; auto itl = a.begin(); // list<string>::iterator auto it2 = a.rbegin(); // list<string>::reverse_iterator auto it3 = a.cbegin(); // list<string>::const_iterator auto it4 = a.crbegin();// list<string>::const_reverse_iterator The functions that do not begin with a c are overloaded. That is, there are actually two members named begin. One is a const member (S 7.1.2, p. 258) that re- turns the container's const iterator type. The other is nonconst and returns the container's iterator type. Similarly for rbegin, end, and rend. When we",Sequential Containers
Exercise 9.9,What is the difference between the begin and cbegin functions?.,Sequential Containers
Exercise 9.10,"What are the types of the following four objects? vector<int> vl; const vector<int> v2; auto itl = vl.begin(), it2 = v2.begin(); auto it3 = vl.cbegin(), it4 = v2.cbegin(); 9.2.4Defining and Initializing a Container Every container type defines a default constructor ($ 7.1.4, p. 263). With the excep- tion of array, the default constructor creates an empty container of the specified type. Again excepting array, the other constructors take arguments that specify the size of the container and initial values for the elements. Initializing a Container as a Copy of Another Container There are two ways to create a new container as a copy of another one: We can directly copy the container, or (excepting array) we can copy a range of elements. denoted by a pair of iterators. To create a container as a copy of another container, the container and element types must match. When we pass iterators, there is no requirement that the con- tainer types be identical. Moreover, the element types in the new and original",Sequential Containers
Exercise 9.11,Show an example of each of the six ways to create and initialize a vector. Explain what values each vector contains..,Sequential Containers
Exercise 9.12,Explain the differences between the constructor that takes a container to copy and the constructor that takes two iterators.,Sequential Containers
Exercise 9.13,"How would you initialize a vector<double> from a list<int>? From a vector<int >? Write code to check your answers.. 9.2.5Assignment and swap The assignment-related operators, listed in Table 9.4 (overleaf) act on the entire container. The assignment operator replaces the entire range of elements in the left-hand container with copies of the elements from the right-hand operand: c1 = c2; 1 /replace the contents of c1 with a copy of the elements in c2. c1 ={a,b,c};// after the assignment c1has size3 After the first assignment, the left- and right-hand containers are equal. If the containers had been of unequal size, after the assignment both containers would have the size of the right-hand operand. After the second assignment, the si ze of. c1 is 3, which is the number of values provided in the braced list.",Sequential Containers
Exercise 9.14,"Write a program to assign the elements from a 1ist of char + pointers to C-style character strings to a vector of strings 9.2.6 Container Size Operations With one exception, the container types have three size-related operations. The si ze member (S 3.2.2, p. 87) returns the number of elements in the container; empty returns a bool that is true if size is zero and false otherwise; and max size returns a number that is greater than or equal to the number of ele- ments a container of that type can contain. For reasons well explain in the next section, forward list provides max sizeand empty, but not size. 9.2.7 Relational Operators Every container type supports the equality operators (== and ! =); all the contain- ers except the unordered associative containers also support the relational oper- ators (>, >=, <, <=). The right- and left-hand operands must be the same kind of container and must hold elements of the same type. That is, we can com- pare a vector<int> only with another vector<int>. We cannot compare a vector<int> witha list<int>ora vector<double>. Comparing two containers performs a pairwise comparison of the elements. These operators work similarly to the st ring relationals (S 3.2.2, p. 88): If both containers are the same size and all the elements are equal, then the. two containers are equal; otherwise, they are unequal. . If the containers have different sizes but every element of the smaller one is. equal to the corresponding element of the larger one, then the smaller one is less than the other. If neither container is an initial subsequence of the other, then the comparison depends on comparing the first unequal elements. The following examples illustrate how these operators work. vector<int>vl ={1,35,7,912}; vector<int>v2 ={139}; vector<int>v3 ={1,35,7}; vector<int>v4 ={1,35,7,912}; vl  v2 true; v1 and v2 differ at element [2]: v1 [2] is less than v2 [2] v1 < v3 // fa 1 se; all elements are equal, but v3 has fewer of them; v1 == v4 // true; each element is equal and v1 and v4 have the same si ze () v1 s=v2// fa1se; v2 has fewer elements than v1",Sequential Containers
Exercise 9.15,Write a program to determine whether two vector<int >s are equal..,Sequential Containers
Exercise 9.16,"Repeat the previous program, but compare elements in a 1ist<int >. to a vector<int>.",Sequential Containers
Exercise 9.17,"Assuming c1 and c2 are containers, what (if any) constraints does the following usage place on the types of c1 and c2? if cl <c2) 9.3 Sequential Container Operations The sequential and associative containers differ in how they organize their ele- ments. These differences affect how elements are stored, accessed, added, and re-. moved. The previous section covered operations common to all containers (those. listed in Table 9.2 (p. 330). Well cover the operations specific to the sequential containers in the remainder of this chapter. 9.3.1 Adding Elements to a Sequential Container Excepting array, all of the library containers provide flexible memory manage- ment. We can add or remove elements dynamically changing the size of the con tainer at run time. Table 9.5 (p. 343) lists the operations that add elements to a (nonarray) sequential container. When we use these operations, we must remember that the containers use. different strategies for allocating elements and that these strategies affect perfor mance. Adding elements anywhere but at the end of a vector or string, or. anywhere but the beginning or end of a deque, requires elements to be moved.",Sequential Containers
Exercise 9.18,Write a program to read a sequence of st rings from the standard input into a deque. Use iterators to write a loop to print the elements in the deque.,Sequential Containers
Exercise 9.19,Rewrite the program from the previous exercise to use a 1ist. List the changes you needed to make..,Sequential Containers
Exercise 9.20,Write a program to copy elements from a li st <int > into two deques. The even-valued elements should go into one deque and the odd ones into the other..,Sequential Containers
Exercise 9.21,Explain how the loop from page 345 that used the return from insert. to add elements to a 1ist would work if we inserted into a vector instead.,Sequential Containers
Exercise 9.22,"Assuming iv is a vector of ints, what is wrong with the following. program? How might you correct the problem(s)? vector<int>::iterator iter = iv.begin(), mid = iv.begin() + iv.size()/2; while (iter != mid) if (*iter == some_val) iv.insert(iter, 2 * some_val); 9.3.2Accessing Elements Table 9.6 lists the operations we can use to access elements in a sequential con-. tainer. The access operations are undefined if the container has no elements. Each sequential container, including array, has a front member, and all ex-. cept forward_1ist also have a back member. These operations return a refer ence to the first and last element, respectively: / /  check that there are elements before dereferencing an iterator or calling f ront or back if c.empty{ I/ vaI and va1 2 are copies of the value of the first element in c auto val = *c.begin(), val2 = c.front(); I/ vaI 3 and vaI4 are copies of the of the last element in c auto last = c.end(); auto val3 = *(--last); // cant decrement forward list iterators auto val4 = c.back();// not supported by forward list",Sequential Containers
Exercise 9.23,"In the first program in this section on page 346, what would the values of val, val2, val3, and val4 be if c. size () is 1?",Sequential Containers
Exercise 9.24,"Write a program that fetches the first element in a vector using at, the subscript operator, front, and begin. Test your program on an empty vector. 9.3.3 Erasing Elements Just as there are several ways to add elements to a (nonarray) container there are. also several ways to remove elements. These members are listed in Table 9.7. The members that remove elements do not check their argument(s). The WARNING programmer must ensure that element(s) exist before removing them. The pop front and pop back Members The pop front and pop back functions remove the first and last elements, re- spectively. Just as there is no push front for vector and string, there is also no pop_front for those types. Similarly, forward_list does not have pop_back. Like the element access members, we may not use a pop operation on an empty container.. These operations return void. If you need the value you are about to pop, you must store that value before doing the pop: while (!ilist.empty()){ process (ilist.front ()) ; // do something with the current top of ilist ilist.pop_front(); //done; remove the first element",Sequential Containers
Exercise 9.25,"In the program on page 349 that erased a range of elements, what hap. pens if eleml and elem2 are equal? What if elem2 or both elem1 and elem2 are the. off-the-end iterator?",Sequential Containers
Exercise 9.26,"Using the following definition of i a, copy ia into a vector and into a. 1ist. Use the single-iterator form of erase to remove the elements with odd values. from your 1ist and the even values from your vector. int ia[]={0,112,3,5,8,13,21,55,89}; 9.3.4 Specialized forward 1ist Operations To understand why forward 1ist has special versions of the operations to add and remove elements, consider what must happen when we remove an element from a singly linked list. As illustrated in Figure 9.1, removing an element changes the links in the sequence. In this case, removing elemg changes elem; elem had pointed to elem3, but after we remove elem3, elem points to elem4. Figure 9.1: forward 1ist Specialized Operations elem elem2 elem3 elems Removing elemg changes the value of elem2 elem elem2 elems When we add or remove an element, the element before the one we added or. removed has a different successor. To add or remove an element, we need access to its predecessor in order to update that element's links. However, forward 1ist is a singly linked list. In a singly linked list there is no easy way to get to an element's predecessor. For this reason, the operations to add or remove elements in a forward 1ist operate by changing the element after the given element. That way, we always have access to the elements that are affected by the change.. Because these operations behave differently from the operations on the other containers, forward list does not define insert, emplace, or erase. Instead it defines members (listed in Table 9.8)named insert after, emplace after,.",Sequential Containers
Exercise 9.27,Write a program to find and remove the odd-valued elements in a forward list<int>.,Sequential Containers
Exercise 9.28,"Write a function that takes a forward_1ist<string> and two addi- tional string arguments. The function should find the first string and insert the. second immediately following the first. If the first str ing is not found, then insert the second string at the end of the list. 9.3.5Resizing a Container With the usual exception of arrays, we can use resi ze, described in Table 9.9, to make a container larger or smaller. If the current size is greater than the requested. size, elements are deleted from the back of the container; if the current size is less than the new size, elements are added to the back of the container: list<int> ilist (10, 42); // ten ints:each has value 42 ilist.resize(l5); // adds five elements of value O to the back of ilist. ilist.resize (25,-1) ; // adds ten elements of value -1 to the backof i1ist ilist.resize(5); //erases 20 elements from the back of i1ist The resi ze operation takes an optional element-value argument that it uses to initialize any elements that are added to the container. If this argument is absent, added elements are value initialized ($ 3.3.1, p. 98). If the container holds elements of a class type and resi ze adds elements, we must supply an initializer or the element type must have a default constructor. Table 9.9: Sequential Container Size Operations resize not valid for array.. c.resize (n) Resize c so that it has n elements. If n < c. si ze () , the excess elements are discarded. If new elements must be added, they are value initialized c. resi ze (n, t) Resize c to have n elements. Any elements added have value t If resi ze shrinks the container, then iterators, references, and pointers to the deleted elements are invalidated; resi ze on a vector, string, or deque potentially inval- WARNING idates all iterators, pointers, and references.",Sequential Containers
Exercise 9.29,"Given that vec holds 25 elements, what does vec. resize (100) do? What if we next wrote vec.resize (10)?.",Sequential Containers
Exercise 9.30,"What, if any, restrictions does using the version of resi ze that takes a single argument place on the element type? 9.3.6 Container Operations May Invalidate Iterators Operations that add or remove elements from a container can invalidate pointers. references, or iterators to container elements. An invalidated pointer, reference, or iterator is one that no longer denotes an element. Using an invalidated pointer, reference, or iterator is a serious programming error that is likely to lead to the same kinds of problems as using an uninitialized pointer ($ 2.3.2, p. 54) After an operation that adds elements to a container . Iterators, pointers, and references to a vector or string are invalid if the container was reallocated. If no reallocation happens, indirect references to elements before the insertion remain valid; those to elements after the inser- tion are invalid.. Iterators, pointers, and references to a deque are invalid if we add elements anywhere but at the front or back. If we add at the front or back, iterators are invalidated, but references and pointers to existing elements are not. Iterators, pointers, and references (including the off-the-end and the before the-beginning iterators) to a list or forward_1ist remain valid,. It should not be surprising that when we remove elements from a container, iterators, pointers, and references to the removed elements are invalidated. After all, those elements have been destroyed. After we remove an element, All other iterators, references, or pointers (including the off-the-end and the before-the-beginning iterators) to a list or forward 1ist remain valid. All other iterators, references, or pointers to a deque are invalidated if the. removed elements are anywhere but the front or back. If we remove elements at the back of the deque, the off-the-end iterator is invalidated but other iterators, references, and pointers are unaffected; they are also unaffected if we remove from the front.. . All other iterators, references, or pointers to a vector or string remain valid for elements before the removal point. Note: The off-the-end iterator is always invalidated when we remove elements.. It is a serious run-time error to use an iterator, pointer, or reference that. WARNING has been invalidated.",Sequential Containers
Exercise 9.31,The program on page 354 to remove even-valued elements and dupli- cate odd ones will not work on a list or forward_1ist. Why? Revise the program so that it works on these types as well.,Sequential Containers
Exercise 9.32,"In the program onpage 354 would it be legal to write the call to insert as follows? If not, why not? iter = vi.insert(iter, *iter++);",Sequential Containers
Exercise 9.33,In the final example in this section what would happen if we did not assign the result of insert to begin? Write a program that omits this assignment to see if your expectation was correct.,Sequential Containers
Exercise 9.34,"Assuming vi is a container of ints that includes even and odd values, predict the behavior of the following loop. After you've analyzed this loop, write a program to test whether your expectations were correct. iter = vi.begin(); while (iter != vi.end()) if *iter % 2) iter = vi.insert(iter, *iter); ++iter; To avoid these costs, library implementors use allocation strategies that reduce the number of times the container is reallocated. When they have to get new memory, vector and st ring implementations typically allocate capacity beyond what is immediately needed. The container holds this storage in reserve and uses it to allocate new elements as they are added. Thus, there is no need to reallocate the container for each new element. This allocation strategy is dramatically more efficient than reallocating the con- tainer each time an element is added. In fact, its performance is good enough that in practice a vector usually grows more efficiently than a list or a deque, even though the vect or has to move all of its elements each time it reallocates memory Members to Manage Capacity The vector and st ring types provide members, described in Table 9.10, that let us interact with the memory-allocation part of the implementation. The capacity operation tells us how many elements the container can hold before it must allocate more space. The reserve operation lets us tell the container how many elements it should be prepared to hold. Note reserve does not change the number of elements in the container; it affects only how much memory the vector preallocates. A call to reserve changes the capacity of the vector only if the requested space exceeds the current capacity. If the requested size is greater than the current",Sequential Containers
Exercise 9.35,Explain the difference between a vector's capacity and its size.,Sequential Containers
Exercise 9.36,Can a container have a capacity less than its size?,Sequential Containers
Exercise 9.37,Why dont list or array have a capacity member?.,Sequential Containers
Exercise 9.38,Write a program to explore how vectors grow in the library you use.,Sequential Containers
Exercise 9.39,Explain what the following program fragment does:. vector<string> svec; svec.reserve(1024) ; string word; while (cin >> word) svec.push_back (word) ; svec.resize (svec.size()+svec.size ()/2) ;,Sequential Containers
Exercise 9.40,"If the program in the previous exercise reads 256 words, what is its likely capacity after it is resi zed? What if it reads 512? 1,000? 1,048?",Sequential Containers
Exercise 9.41,Write a program that initializes a string from a vector<char>,Sequential Containers
Exercise 9.42,"Given that you want to read a character at a time into a string, and you know that you need to read at least 100 characters, how might you improve the performance of your program? 9.5.2 Other Ways to Change a string The string type supports the sequential container assignment operators and the assign, insert, and erase operations ($ 9.2.5, p. 337, S 9.3.1, p. 342, and $ 9.3.3 p. 348). It also defines additional versions of insert and erase..",Sequential Containers
Exercise 9.43,"Write a function that takes three strings, s, oldVal, and newVal. Using iterators, and the insert and erase functions replace all instances of oldVal that appear in s by newVa1. Test your function by using it to replace common abbre-",Sequential Containers
Exercise 9.44,Rewrite the previous function using an index and rep1ace.,Sequential Containers
Exercise 9.45,"Write a funtion that takes a string representing a name and two other strings representing a prefix, such as Mr."" or ""Ms."" and a suffix, such as Jr."" or III. Using iterators and the insert and append functions, generate and return a new string with the suffix and prefix added to the given name.",Sequential Containers
Exercise 9.46,"Rewrite the previous exercise using a position and length to manage the strings. This time use only the insert function.. 9.5.3 string Search Operations The string class provides six different search functions, each of which has four. overloaded versions. Table 9.14 describes the search members and their argu- ments. Each of these search operations returns a string : : si ze_type value that is the index of where the match occurred. If there is no match, the function returns. a static member ($ 7.6, p. 300) named string : : npos. The library defines npos as a const string: : size_type initialized with the value -1. Because npos is an unsigned type, this initializer means npos is equal to the largest possible size. any st ring could have ($ 2.1.2, p. 35) The string search functions return string: :size type, which is an unsigned type. As a result, it is a bad idea to use an int, or other WARNINGE signed type, to hold the return from these functions ($ 2.1.2, p. 36) The f ind function does the simplest search. It looks for its argument and re- turns the index of the first match that is found, or npos if there is no match:",Sequential Containers
Exercise 9.47,"Write a program that finds each numeric character and then each alpha- betic character in the string ""ab2c3d7R4E6"". Write two versions of the program.. The first should use find_first_of,and the second find_first_not_of.",Sequential Containers
Exercise 9.48,"Given the definitions of name and numbers on page 365, what does numbers.find (name) return?",Sequential Containers
Exercise 9.49,"A letter has an ascender if, as with d or f, part of the letter extends above the middle of the line. A letter has a descender if, as with p or g, part of the letter extends below the line. Write a program that reads a file containing words and reports the longest word that contains neither ascenders nor descenders. As shown in Table 9.15, there are six versions of compare. The arguments vary. based on whether we are comparing two strings or a string and a character array. In both cases, we might compare the entire string or a portion thereof. Table 9.15:Possible Arguments to s.compare s2 Compare s to s2. posl,nl,s2 Compares n1 characters starting at pos1 from s to s2. posl, nl,s2,pos2,n2 Compares n1 characters starting at pos1 from s to the n2 characters starting at pos2 in s2. cp Compares s to the null-terminated array pointed to by cp. posl, nl, cp Compares n1 characters starting at pos1 from s to cp. posl,nl, cp,n2 Compares n1 characters starting at pos1 from s to n2 characters starting from the pointer cp. 9.5.5Numeric Conversions Strings often contain characters that represent numbers. For example, we repre sent the numeric value 15 as a string with two characters, the character '1' followed by the character ' 5'. In general, the character representation of a num-. ber differs from its numeric value. The numeric value 15 stored in a 16-bit short resented as two Latin-1 chars has the bit pattern 0011000100110101. The first byte represents the character '1' which has the octal value 061, and the second byte represents ' 5 ' , which in Latin-1 is octal 065 The new standard introduced several functions that convert between numeric. C+- data and library strings:. int i = 42; string s = to_string(i); / //converts the int i to its character representation double d = stod(s) ; //converts the string s to floating-point",Sequential Containers
Exercise 9.50,Write a program to process a vector<string>s whose elements rep resent integral values. Produce the sum of all the elements in that vector. Change the program so that it sums of st rings that represent floating-point values.,Sequential Containers
Exercise 9.51,"Write a class that has three unsigned members representing year, month, and day. Write a constructor that takes a string representing a date. Your constructor should handle a variety of date formats, such as January 1, 1900, 1/1/1900, Jan 1, 1900, and so on. concept in the library. There are container, iterator, and function adaptors. Essen- tially, an adaptor is a mechanism for making one thing act like another. A container adaptor takes an existing container type and makes it act like a different type. For example, the stack adaptor takes a sequential container (other than array or forward 1ist) and makes it operate as if it were a stack. Table 9.17 lists the operations and types that are common to all the container adaptors. Table 9.17: Operations and Types Common to the Container Adaptors size_type Type large enough to hold the size of the largest object of this type. value_type. Element type. container_type Type of the underlying container on which the adaptor is implemented Aa; Create a new empty adaptor named a. A a(c); Create a new adaptor named a with a copy of the container c.. relational operators Each adaptor supports all the relational operators: ==, ! =, <, < =, >, >: These operators return the result of comparing the underlying containers.d a.empty() false if a has any elements, true otherwise. a.size() Number of elements in a. swap(a,b) Swaps the contents of a and b; a and b must have the same type, includ a.swap(b) ing the type of the container on which they are implemented. Defining an Adaptor Each adaptor defines two constructors: the default constructor that creates an empty object, and a constructor that takes a container and initializes the adaptor by copying the given container. For example, assuming that deq is a deque<int >, we can use deq to initialize a new stack as follows: stack<int> stk (deq) ; // copies elements from deq into stk By default both stack and queue are implemented in terms of deque, and a priority_queue is implemented on a vector. We can override the default we create the adaptor:",Sequential Containers
Exercise 9.52,"Use a stack to process parenthesized expressions. When you see an parenthesis, pop elements down to and including the open parenthesis off the st ack. push a value onto the stack to indicate that a parenthesized expression was replaced.",Sequential Containers
Exercise 10.1,"The algorithm header defines a function named count that, like find, takes a pair of iterators and a value. count returns a count of how often that value appears. Read a sequence of ints into a vector and print the count of how many elements have a given value.",Generic Algorithms
Exercise 10.2,"Repeat the previous program, but read values into a 1ist of strings. KEY CONCEPT: ALGORITHMS NEVER EXECUTE CONTAINER OPERATIONS The generic algorithms do not themselves execute container operations. They operate solely in terms of iterators and iterator operations. The fact that the algorithms op- erate in terms of iterators and not container operations has a perhaps surprising but essential implication: Algorithms never change the size of the underlying container. Algorithms may change the values of the elements stored in the container, and they may move elements around within the container. They do not, however, ever add or remove elements directly. As well see in $ 10.4.1 (p. 401), there is a special class of iterator, the inserters, that do more than traverse the sequence to which they are bound. When we assign to these iterators, they execute insert operations on the underlying container. When an algorithm operates on one of these iterators, the iterator may have the effect of adding elements to the container. The algorithm itself, however, never does so. 10.2A First Look at the Algorithms The library provides more than 100 algorithms. Fortunately, like the containers, the algorithms have a consistent architecture. Understanding this architecture makes learning and using the algorithms easier than memorizing all 100+ of them. In this chapter, well illustrate how to use the algorithms, and describe the unifying principles that characterize them. Appendix A lists all the algorithms classified by. how they operate. With only a few exceptions, the algorithms operate over a range of elements range always use their first two parameters to denote that range. These parameters are iterators denoting the first and one past the last elements to process. Although most algorithms are similar in that they operate over an input range,. they differ in how they use the elements in that range. The most basic way to understand the algorithms is to know whether they read elements, write elements, or rearrange the order of the elements.",Generic Algorithms
Exercise 10.3,Use accumulate to sum the elements in a vector<int >.,Generic Algorithms
Exercise 10.4,"Assuming v is a vector<double>, what, if anything, is wrong with calling accumulate (v.cbegin(), v.cend(), 0)?",Generic Algorithms
Exercise 10.5,"In the call to equa1 on rosters, what would happen if both rosters held. C-style strings, rather than library st rings?. 10.2.2 Algorithms That Write Container Elements. Some algorithms assign new values to the elements in a sequence. When we use an algorithm that assigns to elements, we must take care to ensure that the sequence into which the algorithm writes is at least as large as the number of elements we ask the algorithm to write. Remember, algorithms do not perform container oper- ations, so they have no way themselves to change the size of a container. Some algorithms write to elements in the input range itself. These algorithms are not inherently dangerous because they write only as many elements as are in the specified range. As one example, the f i11 algorithm takes a pair of iterators that denote a range. and a third argument that is a value. fi11 assigns the given value to each element in the input sequence:.",Generic Algorithms
Exercise 10.6,"Using fi11_n, write a program to set a sequence of int values to 0.",Generic Algorithms
Exercise 10.7,"Determine if there are any errors in the following programs and, if so, correct the error(s): (a) vector<int> vec; list<int> lst; int i; while (cin >> i) lst.push back(i); copy(lst.cbegin(), lst.cend(), vec.begin()); (b) vector<int> vec; vec.reserve (10) ; // reserve is covered in 9.4 (p.356) fill_nvec.begin(), 10, 0;",Generic Algorithms
Exercise 10.8,"We said that algorithms do not change the size of the containers over which they operate. Why doesn't the use of back_inserter invalidate this claim? Eliminating Duplicates To eliminate the duplicated words, we will first sort the vect or so that duplicated words appear adjacent to each other. Once the vector is sorted, we can use an- other library algorithm, named uni que, to reorder the vector so that the unique elements appear in the first part of the vector. Because algorithms cannot do. container operations, well use the erase member of vector to actually remove the elements: void elimDups(vector<string> &words) I /sort words alphabetically so we can find the duplicates sort (words.begin(), words.end()); / /  uni que reorders the input range so that each word appears once in the. / /front portion of the range and returns an iterator one past the unique range auto end_unique = unique(words.begin(), words.end()); I / erase uses a vector operation to remove the nonunique elements. words.erase(end_unique, words.end()); Ihe sort algorithm takes two iterators denoting the range of elements to sort. In. this call, we sort the entire vector. After the call to sort, words is ordered as fox jumps over quickredredslowthe the turtle Note that the words red and the appear twice.. Using unique Once words is sorted, we want to keep only one copy of each word. The unique. algorithm rearranges the input range to ""eliminate"" adjacent duplicated entries,",Generic Algorithms
Exercise 10.9,"Implement your own version of elimDups. Test your program by printing the vector after you read the input, after the call to unique, and after the call to erase..",Generic Algorithms
Exercise 10.10,"Why do you think the algorithms don't change the size of containers? 10.3Customizing Operations Many of the algorithms compare elements in the input sequence. By default, such algorithms use either the element type's < or == operator. The library also defines versions of these algorithms that let us supply our own operation to use in place of the default operator.",Generic Algorithms
Exercise 10.11,Write a program that uses stable_sort and isShorter to sort a vector passed to your version of elimDups. Print the vector to verify that your. program is correct.,Generic Algorithms
Exercise 10.12,Write a function named compareIsbn that compares the isbn () members of two Sales_data objects. Use that function to sort a vector that holds. Sales_data objects.,Generic Algorithms
Exercise 10.13,"The library defines an algorithm named part i t i on that takes a pred-. icate and partitions the container so that values for which the predicate is t rue appear in the first part and those for which the predicate is fa1 se appear in the second part. The algorithm returns an iterator just past the last element for which the predicate returned true. Write a function that takes a string and returns a bool indicating whether the st ring has five characters or more. Use that function to partition words. Print the elements that have five or more characters. 10.3.2Lambda Expressions The predicates we pass to an algorithm must have exactly one or two parameters, depending on whether the algorithm takes a unary or binary predicate, respec tively. However, sometimes we want to do processing that requires more argu- ments than the algorithm's predicate allows. For example, the solution you wrote. for the last exercise in the previous section had to hard-wire the size 5 into the pred icate used to partition the sequence. It would be move useful to be able to partition a sequence without having to write a separate predicate for every possible size. As a related example, well revise our program from $ 10.3.1 (p. 387) to report how many words are of a given size or greater. Well also change the output so that it prints only the words of the given length or greater. A sketch of this function, which well name biggies, is as follows:.",Generic Algorithms
Exercise 10.14,Write a lambda that takes two ints and returns their sum.,Generic Algorithms
Exercise 10.15,Write a lambda that captures an int from its enclosing function and takes an int parameter. The lambda should return the sum of the captured int and the int parameter.,Generic Algorithms
Exercise 10.16,Write your own version of the biggies function using lambdas.,Generic Algorithms
Exercise 10.17,Rewrite exercise 10.12 from  10.3.1 (p. 387) to use a lambda in the call to sort instead of the compareIsbn function..,Generic Algorithms
Exercise 10.18,Rewrite biggies to use partition instead of find_if. We de- scribed the part it ion algorithm in exercise 10.13 in $ 10.3.1 (p. 387).,Generic Algorithms
Exercise 10.19,"Rewrite the previous exercise to use stable_partition, which like stable_sort maintains the original element order in the paritioned sequence 10.3.3Lambda Captures and Returns When we define a lambda, the compiler generates a new (unnamed) class type that. corresponds to that lambda. Well see how these classes are generated in $ 14.8.1 (p. 572). For now, what's useful to understand is that when we pass a lambda to a function, we are defining both a new type and an object of that type: The argument is an unnamed object of this compiler-generated class type. Similarly, when we use auto to define a variable initialized by a lambda, we are defining an object of the type generated from that lambda. By default, the class generated from a lambda contains a data member corre- sponding to the variables captured by the lambda. Like the data members of any class, the data members of a lambda are initialized when a lambda object is created. Capture by Value Similar to parameter passing, we can capture variables by value or by reference.. Table 10.1 (p.395) covers the various ways we can form a capture list.So far, our lambdas have captured variables by value. As with a parameter passed by value, it must be possible to copy such variables. Unlike parameters, the value of a captured variable is copied when the lambda is created, not when it is called. void fcnl() size_t v1 =42// local variable I /copies v1 into the callable object named f auto f = [vl] {return vl; }; v1=0 auto j = f();// j is 42;f stored a copy ofv1 when we created it 1 Because the value is copied when the lambda is created, subsequent changes to a captured variable have no effect on the corresponding value inside the lambda..",Generic Algorithms
Exercise 10.20,"The library defines an algorithm named count_if. Like find_if, this function takes a pair of iterators denoting an input range and a predicate that it. applies to each element in the given range. count_i f returns a count of how often the predicate is true. Use count_if to rewrite the portion of our program that counted how many words are greater than length 6.",Generic Algorithms
Exercise 10.21,"Write a lambda that captures a local int variable and decrements that variable until it reaches 0. Once the variable is 0 additional calls should no longer decrement the variable. The lambda should return a bool that indicates whether the captured variable is 0. 10.3.4Binding Arguments Lambda expressions are most useful for simple operations that we do not need to use in more than one or two places. If we need to do the same operation in many places, we should usually define a function rather than writing the same lambda expression multiple times. Similarly, if an operation requires many statements, it. is ordinarily better to use a function. It is usually straightforward to use a function in place of a lambda that has an. empty capture list. As we've seen, we can use either a lambda or our isShorter function to order the vector on word length. Similarly, it would be easy to replace. the lambda that printed the contents of our vect or by writing a function that takes a string and prints the given string to the standard output. However, it is not so easy to write a function to replace a lambda that captures local variables. For example, the lambda that we used in the call to find if same work: bool check_size(const string &s, string::size_type sz). return s.size() >= sz; However, we can't use this function as an argument to find if. As we've seen find if takes a unary predicate, so the callable passed to find if must take a list to store sz. In order to use check si ze in place of that lambda, we have to. The Library bind Function We can solve the problem of passing a size argument to check size by using a new library function named bind, which is defined in the functiona1 header. The bind function can be thought of as a general-purpose function adaptor ($ 9.6,) p. 368). It takes a callable object and generates a new callable that ""adapts"" the parameter list of the original object.",Generic Algorithms
Exercise 10.22,Rewrite the program to count words of size 6 or less using functions in place of the lambdas.,Generic Algorithms
Exercise 10.23,How many arguments does bind take?.,Generic Algorithms
Exercise 10.24,Use bind and check_size to find the first element in a vector of ints that has a value greater than the length of a specified string value.,Generic Algorithms
Exercise 10.25,"In the exercises for  10.3.2 (p. 392) you wrote a version of biggies that uses partition. Rewrite that function to use check_size and bind. 10.4Revisiting Iterators In addition to the iterators that are defined for each of the containers, the library defines several additional kinds of iterators in the iterator header. These itera- tors include Insert iterators: These iterators are bound to a container and can be used to insert elements into the container. Stream iterators: These iterators are bound to input or output streams and can be used to iterate through the associated IO stream.. Reverse iterators: These iterators move backward, rather than forward. The library containers, other than forward_list, have reverse iterators. : Move iterators: These special-purpose iterators move rather than copy their. elements. We11 cover move iterators in $ 13.6.2 (p. 543) 10.4.1Insert Iterators An inserter is an iterator adaptor (S 9.6, p. 368) that takes a container and yields an iterator that adds elements to the specified container. When we assign a value through an insert iterator, the iterator calls a container operation to add an element at a specified position in the given container. The operations these iterators support are listed in Table 10.2 (overleaf).",Generic Algorithms
Exercise 10.26,Explain the differences among the three kinds of insert iterators.,Generic Algorithms
Exercise 10.27,"In addition to unique (S 10.2.3, p. 384), the library defines function named unique_copy that takes a third iterator denoting a destination into which to copy the unique elements. Write a program that uses unique_copy to copy the unique elements from a vector into an initially empty 1i st.",Generic Algorithms
Exercise 10.28,"Copy a vector that holds the values from 1 to 9 inclusive, into three other containers. Use an inserter, a back_inserter, and a front_inserter, respectivly to add elements to these containers. Predict how the output sequence varies by the kind of inserter and verify your predictions by running your programs. 10.4.2 iostreamIterators Even though the iostream types are not containers, there are iterators that can be used with objects of the IO types (S 8.1, p. 310). An istream iterator (Ta- ble 10.3 (overleaf)) reads an input stream, and an ostream_iterator (Table 10.4 (p. 405)) writes an output stream. These iterators treat their corresponding stream as a sequence of elements of a specified type. Using a stream iterator, we can use the generic algorithms to read data from or write data to stream objects Operations on istream_iterators When we create a stream iterator, we must specify the type of objects that the iterator will read or write. An istream_iterator uses >> to read a stream. Therefore, the type that an istream iterator reads must have an input opera- tor defined. When we create an istream iterator, we can bind it to a stream Alternatively, we can default initialize the iterator, which creates an iterator that we can use as the off-the-end value. istream iterator<int> int_it(cin); // reads ints from cin istream_iterator<int> int_eof; //end iterator value ifstream in(""afile""); istream_iterator<string> str_it(in); // reads stringsfrom ""afile"" As an example, we can use an istream iterator to read the standard input into a vector: istream_iterator<int> in_iter (cin); // read intsfrom cin istream iterator<int> eof; //istream""end'iterator while (in iter != eof)// while there's valid input to read // postfix increment reads the stream and returns the old value of the iterator I / we dereference that iterator to get the previous value read from the stream vec.push_back(in_iter++); This loop reads ints from cin, storing what was read in vec. On each iteration, the loop checks whether in iter is the same as eof. That iterator was defined as the empty istream iterator, which is used as the end iterator. An iterator",Generic Algorithms
Exercise 10.29,Write a program using stream iterators to read a text file into a vector. of strings.,Generic Algorithms
Exercise 10.30,"Use stream iterators, sort, and copy to read a sequence of integers from the standard input, sort them, and then write them back to the standard output.",Generic Algorithms
Exercise 10.31,"Update the program from the previous exercise so that it prints only the unique elements. Your program should use unqiue_copy ($ 10.4.1, p. 403).",Generic Algorithms
Exercise 10.32,"Rewrite the bookstore problem from $ 1.6 (p. 24) using a vector to hold the transactions and various algorithms to do the processing. Use sort with your compareI sbn function from  10.3.1 (p. 387) to arrange the transactions in order, and then use find and accumulate to do the sum...",Generic Algorithms
Exercise 10.33,"Write a program that takes the names of an input file and two output files. The input file should hold integers. Using an istream_iterator read the input file. Using ostream_iterators, write the odd numbers into the first output file. Each value should be followed by a space. Write the even numbers into the second file. Each of these values should be placed on a separate line. 10.4.3Reverse Iterators A reverse iterator is an iterator that traverses a container backward, from the last element toward the first. A reverse iterator inverts the meaning of increment (and decrement). Incrementing (++it) a reverse iterator moves the iterator to the pre- vious element; derementing (- - it) moves the iterator to the next element. The containers, aside from forward 1ist, all have reverse iterators. We ob- tain a reverse iterator by calling the rbegin, rend, crbegin, and crend mem- bers. These members return reverse iterators to the last element in the container and one ""past"" (i.e., one before) the beginning of the container. As with ordinary iterators, there are both const and nonconst reverse iterators. Figure 10.1 illustrates the relationship between these four iterators on a hypo thetical vector named vec.. Figure 10.1: Comparing begin/cend and rbegin/crend Iterators vec.cbegin() vec.cend() vec.crend() vec.crbegin() As an example, the following loop prints the elements of vec in reverse order:",Generic Algorithms
Exercise 10.34,Use reverse_iterators to print a vector in reverse order.,Generic Algorithms
Exercise 10.35,Now print the elements in reverse order using ordinary iterators.,Generic Algorithms
Exercise 10.36,Use f ind to find the last element in a 1ist of ints with value 0.,Generic Algorithms
Exercise 10.37,"Given a vector that has ten elements, copy the elements from posi- tions 3 through 7 in reverse order to a 1ist.. 10.5 Structure of Generic Algorithms The most fundamental property of any algorithm is the list of operations it requires from its iterator(s). Some algorithms, such as f ind, require only the ability to ac- cess an element through the iterator, to increment the iterator, and to compare two iterators for equality. Others, such as sort, require the ability to read, write, and randomly access elements. The iterator operations required by the algorithms are grouped into five iterator categories listed in Table 10.5. Each algorithm specifies what kind of iterator must be supplied for each of its iterator parameters. A second way is to classify the algorithms (as we did in the beginning of this chapter) is by whether they read, write, or reorder the elements in the sequence. Appendix A covers all the algorithms according to this classification. The algorithms also share a set of parameter-passing conventions and a set of naming conventions, which we shall cover after looking at iterator categories. Table 10.5: Iterator Categories Input iterator Read, but not write; single-pass, increment only Output iterator Write, but not read; single-pass, increment only. Forward iterator Read and write; multi-pass, increment only Bidirectional iterator Read and write; multi-pass, increment and decrement Random-access iterator Read and write; multi-pass, full iterator arithmetic 10.5.1 The Five Iterator Categories Like the containers, iterators define a common set of operations. Some operations are provided by all iterators; other operations are supported by only specific kinds. of iterators. For example, ostream iterators have only increment, derefer ence, and assignment. Iterators on vector, strings, and deques support these operations and the decrement, relational, and arithmetic operators. Iterators are categorized by the operations they provide and the categories form a sort of hierarchy. With the exception of output iterators, an iterator of a higher category provides all the operations of the iterators of a lower categories. Ihe standard specifies the minimum category for each iterator parameter of the",Generic Algorithms
Exercise 10.38,List the five iterator categories and the operations that each supports.,Generic Algorithms
Exercise 10.39,What kind of iterator does a li st have? What about a vector?.,Generic Algorithms
Exercise 10.40,"What kinds of iterators do you think copy requires?  What about reverse or unique? 10.5.2Algorithm Parameter Patterns Superimposed on any other classification of the algorithms is a set of parameter conventions. Understanding these parameter conventions can aid in learning new algorithmsby knowing what the parameters mean, you can concentrate on un derstanding the operation the algorithm performs. Most of the algorithms have one of the following four forms: alg(beg,end,otherargs); alg(beg, end, dest, other args); alg(beg, end,beg2,other args; alg(beg,end,beg2, end2,otherargs; where alg is the name of the algorithm, and beg and end denote the input range. on which the algorithm operates. Although nearly all algorithms take an input",Generic Algorithms
Exercise 10.41,"Based only on the algorithm and argument names, describe the oper-. ation that the each of the following library algorithms performs:. replace(beg, end, old_val, new_val); replace_if(beg, end, pred, new_val); replace_copy(beg, end, dest, old val, new val); replace_copy_if(beg, end, dest, pred, new_val); 10.6 Container-Specific Algorithms Unlike the other containers, 1ist and forward 1ist define several algorithms as members. In particular, the list types define their own versions of sort, merge, remove, reverse, and unique. The generic version of sort requires random- access iterators. As a result, sort cannot be used with list and forward 1ist because these types offer bidirectional and forward iterators, respectively. The generic versions of the other algorithms that the list types define can be used with lists, but at a cost in performance. These algorithms swap elements in the input sequence. A list can ""swap"" its elements by changing the links among its elements rather than swapping the values of those elements. As a result, the list- specific versions of these algorithms can achieve much better performance than the corresponding generic versions. These 1ist-specific operations are described in Table 10.6. Generic algorithms not listed in the table that take appropriate iterators execute equally efficiently on. lists and forward listss as on other containers. Best The list member versions should be used in preference to the generic Practices algorithms for lists and forward lists.. Table 10.6: Algorithms That are Members of 1ist and forward 1ist These operations return void.. 1st.merge (lst2) Merges elements from 1st2 onto 1st. Both 1st and 1st2 1st.merge (lst2, comp) must be sorted. Elements are removed from 1st2. After the merge, 1st2 is empty. The first version uses the < operator;. the second version uses the given comparison operation. 1st.remove (val) Calls erase to remove each element that is == to the given 1st.remove_if(pred) value or for which the given unary predicate succeeds.. 1st.reverse() Reverses the order of the elements in 1st. 1st.sort() Sorts the elements of 1 st using < or the given comparison op- 1st.sort (comp) eration. 1st.unique() Calls erase to remove consecutive copies of the same value. 1st.unique (pred) The first version uses ==; the second uses the given binary predicate.",Generic Algorithms
Exercise 10.42,Reimplement the program that eliminated duplicate words that we wrote in  10.2.3 (p. 383) to use a 1ist instead of a vector.,Generic Algorithms
Exercise 11.1,Describe the differences between a map and a vector.,Associative Containers
Exercise 11.2,"Give an example of when each of list, vector, deque, map, and set might be most useful.",Associative Containers
Exercise 11.3,Write your own version of the word-counting program.,Associative Containers
Exercise 11.4,"Extend your program to ignore case and punctuation. For example, example."" ""example,"" and Example should all increment the same counter.",Associative Containers
Exercise 11.5,Explain the difference between a map and a set. When might you use one or the other?,Associative Containers
Exercise 11.6,Explain the difference between a set and a 1ist. When might you use One or the other?,Associative Containers
Exercise 11.7,Define a map for which the key is the family's last name and the value is a vector of the children's names. Write code to add new families and to add new. children to an existing family.,Associative Containers
Exercise 11.8,"Write a program that stores the excluded words in a vector instead of in a set. What are the advantages to using a set?. 11.2.2 Requirements on Key Type. The associative containers place constraints on the type that is used as a key. We1l cover the requirements for keys in the unordered containers in S 11.4 (p. 445). For the ordered containers-map, mult imap, set, and multiset-the key type must define a way to compare the elements. By default, the library uses the < operator for the key type to compare the keys. In the set types, the key is the element type;",Associative Containers
Exercise 11.9,"Define a map that associates words with a 1ist of line numbers on which the word might occur. Exercise11.10: Could we define a map from vector<int>: :iterator to int? What about from list<int >: : iterator to int? In each case, if not, why not?",Associative Containers
Exercise 11.11,"Redefine bookstore without using decltype 11.2.3 The pair Type Before we look at the operations on associative containers, we need to know about the library type named pair, which is defined in the uti1ity header. A pair holds two data members. Like the containers, pair is a template from which we generate specific types. We must supply two type names when we create a pair. The data members of the pair have the corresponding types. There is no requirement that the two types be the same:. pair<string, string> anon; //holds two strings pair<string, size_t> word_count; // holdsa stringandan size_t pair<string, vector<int>> line; // holds stringand vector<int>",Associative Containers
Exercise 11.12,"Write a program to read a sequence of st rings and ints, storing each into a pair. Store the pairs in a vector.",Associative Containers
Exercise 11.13,"There are at least three ways to create the pairs in the program for the previous exercise. Write three versions of that program, creating the pairs in each way. Explain which form you think is easiest to write and understand, and why",Associative Containers
Exercise 11.14,"Extend the map of children to their family name that you wrote for the exercises in $ 11.2.1 (p. 424) by having the vector store a pair that holds a childs name and birthday. 11.3 Operations on Associative Containers In addition to the types listed in Table 9.2 (p. 330), the associative containers define. the types listed in Table 11.3. These types represent the container's key and value types. For the set types, the key type and the value type are the same; the values held in a set are the keys. In a map, the elements are key-value pairs. That is, each element is a pair object containing a key and a associated value. Because we cannot change an element's key, the key part of these pairs is const:",Associative Containers
Exercise 11.15,"What are the mapped_type, key_type, and value_type of a map from int to vector<int>?",Associative Containers
Exercise 11.16,Using a map iterator write an expression that assigns a value to an. element.,Associative Containers
Exercise 11.17,"Assuming c is a multiset of strings and v is a vector of. strings, explain the following calls. Indicate whether each call is legal: copy(v.begin(), v.end(), inserter(c, c.end())); copy(v.begin(),v.end(), back_inserter(c)); copy(c.begin(), c.end(), inserter(v, v.end())); copy(c.begin(), c.end(), back_inserter(v));",Associative Containers
Exercise 11.18,Write the type of map_it from the loop on page 430 without using auto or decltype..,Associative Containers
Exercise 11.19,"Define a variable that you initialize by calling begin () on the mu1tiset named bookstore from $ 11.2.2 (p. 425). Write the variables type without. using auto or decltype. 11.3.2Adding Elements The insert members (Table 11.4 (overleaf) add one element or a range of ele- ments. Because map and set (and the corresponding unordered types) contain unique keys, inserting an element that is already present has no effect: vector<int> ivec ={2,4,6,8,2,4,6,8}; // ivec has eight elements set<int> set2; //empty set set2.insert(ivec.cbegin(), ivec.cend()) ; // set2has fourelements set2.insert{1,3,5,7,1,3,5,7}); // set2 now has eight elements The versions of insert that take a pair of iterators or an initializer list work sim- ilarly to the corresponding constructors (S 11.2.1, p. 423)only the first element with a given key is inserted. Adding Elements to a map When we insert into a map, we must remember that the element type is a pair Often, we don't have a pair object that we want to insert. Instead, we create a pair in the argument list to insert: // four ways to add word to word count word_count.insert({word, 1}); word_count.insert (make_pair(word, 1)); word_count.insert(pair<string, size_t>(word, 1)); word_count.insert (map<string, size_t>::value_type(word, 1)); As we've seen, under the new standard the easiest way to create a pair is to use brace initialization inside the argument list. Alternatively, we can call make pair",Associative Containers
Exercise 11.20,Rewrite the word-counting program from S 11.1 (p.421) to use insert instead of subscripting. Which program do you think is easier to write and read? Explain your reasoning.,Associative Containers
Exercise 11.21,"Assuming word_count is a map from string to size_t and word is a string, explain the following loop: while (cin >> word) ++word_count.insert({word, 0}).first->second;",Associative Containers
Exercise 11.22,"Given a map<string, vector<int >>, write the types used as an argument and as the return value for the version of insert that inserts one element.",Associative Containers
Exercise 11.23,"Rewrite the map that stored vectors of childrens names with a key that is the family last name for the exercises in $ 11.2.1 (p. 424) to use a mu1 t imap. 11.3.3 Erasing Elements The associative containers define three versions of erase, which are described in Table 11.5. As with the sequential containers, we can erase one element or a range of elements by passing erase an iterator or an iterator pair. These versions of erase are similar to the corresponding operations on sequential containers: The indicated element(s) are removed and the function returns void. The associative containers supply an additional erase operation that takes a key_type argument. This version removes all the elements, if any, with the given key and returns a count of how many elements were removed.We can use this version to remove a specific word from word_count before printing the results: I / erase on a key returns the number of elements removed if (word_count.erase(removal_word)) cout << ""ok:  << removal_word <<  removed\n""; else cout << ""oops: "" << removal_word <<  not found!\n""; For the containers with unique keys, the return from erase is always either zero or one. If the return value is zero, then the element we wanted to erase was not in the container.",Associative Containers
Exercise 11.24,"What does the following program do? map<int, int> m; m[0]=1;",Associative Containers
Exercise 11.25,Contrast the following program with the one in the previous exercise vector<int> v; v[0]=1;,Associative Containers
Exercise 11.26,"What type can be used to subscript a map? What type does the sub script operator return? Give a concrete example-that is, define a map and then write the types that can be used to subscript the map and the type that would be returned from the subscript operator. is present, it still has to count how many elements have the same key. If we don't need the count, it's best to use f ind:. set<int>iset={0,1,2,3,4,5,6,7,8,9}; iset.find (1); I/returns an iterator that refers to the element with key == 1 iset.find (11); // returns the iterator ==iset.end() iset.count(1);// returns1 iset.count(11); // returns 0 Using find Instead of Subscript for maps For the map and unordered map types, the subscript operator provides the sim plest method of retrieving a value. However, as we've just seen, using a subscript has an important side effect: If that key is not already in the map, then subscript inserts an element with that key. Whether this behavior is correct depends on our expectations. Our word-counting programs relied on the fact that using a nonex- istent key as a subscript inserts an element with that key and value 0. Sometimes, we want to know if an element with a given key is present without changing the map. We cannot use the subscript operator to determine whether an element is present, because the subscript operator inserts a new element if the key is not already there. In such cases, we should use f ind: if (word count.find(""foobar"") == word_count.end()) cout << ""foobar is not in the map"" << endl; Finding Elements in amultimap or multiset Finding an element in an associative container that requires unique keys is a simple matterthe element is or is not in the container. For the containers that allow multiple keys, the process is more complicated: There may be many elements with the given key. When a multimap or multiset has multiple elements of a given key, those elements will be adjacent within the container.",Associative Containers
Exercise 11.27,What kinds of problems would you use count to solve? When might you use f ind instead?,Associative Containers
Exercise 11.28,Define and initialize a variable to hold the result of calling f ind on a map from string to vector of int.,Associative Containers
Exercise 11.29,"What do upper_bound, lower_bound, and equal_range return when you pass them a key that is not in the container?",Associative Containers
Exercise 11.30,Explain the meaning of the operand pos. first- >second used in the output expression of the final program in this section.,Associative Containers
Exercise 11.31,Write a program that defines a mul t imap of authors and their works. Use find to find an element in the multimap and erase that element. Be sure your program works correctly if the element you look for is not in the map.,Associative Containers
Exercise 11.32,"Using the mult imap from the previous exercise, write a program to print the list of authors and their works alphabetically. 11.3.6A Word Transformation Map We'll close this section with a program to illustrate creating, searching, and iterat- ing across a map. Well write a program that, given one string, transforms it into another. The input to our program is two files. The first file contains rules that we. will use to transform the text in the second file. Each rule consists of a word that might be in the input file and a phrase to use in its place. The idea is that when- ever the first word appears in the input, we will replace it with the corresponding. phrase. The second file contains the text to transform.",Associative Containers
Exercise 11.33,Implement your own version of the word-transformation program,Associative Containers
Exercise 11.34,What would happen if we used the subscript operator instead of f ind in the transform function?,Associative Containers
Exercise 11.35,"In bui 1dMap, what effect, if any, would there be from rewriting trans_map[key] = value.substr(1); as trans_map.insert({key, value.substr(1)})?",Associative Containers
Exercise 11.36,"Our program does no checking on the validity of either input file. In particular, it assumes that the rules in the transformation file are all sensible. What would happen if a line in that file has a key, one space, and then the end of the line? Predict the behavior and then check it against your version of the program. 11.4 The Unordered Containers The new standard defines four unordered associative containers.Rather than using a comparison operation to organize their elements, these containers use a hash function and the key types == operator. An unordered container is most C+- useful when we have a key type for which there is no obvious ordering relationship among the elements. These containers are also useful for applications in which the cost of maintaining the elements in order is prohibitive. Although hashing gives better average case performance in principle, achiev- ing good results in practice often requires a fair bit of performance testing and tweaking. As a result, it is usually easier (and often yields better performance) to use an ordered container.",Associative Containers
Exercise 11.37,What are the advantages of an unordered container as compared to the ordered version of that container? What are the advantages of the ordered version?,Associative Containers
Exercise 11.38,"Rewrite the word-counting (S 11.1, p. 421) and word-transformation (S 11.3.6, p. 440) programs to use an unordered_map",Associative Containers
Exercise 12.1,"How many elements do b1 and b2 have at the end of this code? StrBlob b1; StrBlob b2={a,""an"",""the""}; b1 = b2; b2.push_back""about"");",Pointers and Dynamic Memory
Exercise 12.2,Write your own version of the St rB1ob class including the const ver- sions of front and back..,Pointers and Dynamic Memory
Exercise 12.3,"Does this class need const versions of push_back and pop_back? If so, add them. If not, why arent they needed?.",Pointers and Dynamic Memory
Exercise 12.4,In our check function we didn't check whether i was greater than zero. Why is it okay to omit that check?.,Pointers and Dynamic Memory
Exercise 12.5,"We did not make the constructor that takes an initializer_list exp1icit ($ 7.5.4, p. 296). Discuss the pros and cons of this design choice. 12.1.2Managing Memory Directly The language itself defines two operators that allocate and free Pointers and Dynamic Memory. The new operator allocates memory, and delete frees memory allocated by new. For reasons that will become clear as we describe how these operators work using these operators to manage memory is considerably more error-prone than. using a smart pointer. Moreover, classes that do manage their own memory unlike those that use smart pointers-cannot rely on the default definitions for the. members that copy, assign, and destroy class objects ($ 7.1.4, p. 264). As a result, Until you have read Chapter 13, your classes should allocate dynamic WARNING Using new to Dynamically Allocate and Initialize Objects Objects allocated on the free store are unnamed, so new offers no way to name the objects that it allocates. Instead, new returns a pointer to the object it allocates: int *pi = new int; // pi points to a dynamically allocated //unnamed, uninitialized int This new expression constructs an object of type int on the free store and returns a pointer to that object.. By default, dynamically allocated objects are default initialized ($ 2.2.1, p. 43), which means that objects of built-in or compound type have undefined value; ob. jects of class type are initialized by their default constructor:",Pointers and Dynamic Memory
Exercise 12.6,Write a function that returns a dynamically allocated vector of ints. Pass that vector to another function that reads the standard input to give values to. the elements. Pass the vector to another function to print the values that were read.. Remember to delete the vector at the appropriate time.,Pointers and Dynamic Memory
Exercise 12.7,"Redo the previous exercise, this time using shared_ptr..",Pointers and Dynamic Memory
Exercise 12.8,Explain what if anything is wrong with the following function. bool b{ int* p = new int;. //... return p; {,Pointers and Dynamic Memory
Exercise 12.9,"Explain what happens in the following code int *q = new int(42), *r = new int(lo0); b=x auto q2 = make_shared<int>(42), r2 = make_shared<int>(100); r2 =q2;",Pointers and Dynamic Memory
Exercise 12.10,"Explain whether the following call to the process function defined on page 464 is correct. If not, how would you correct the call? shared ptr<int> p(new int(42)); process (shared_ptr<int>(p)) ;",Pointers and Dynamic Memory
Exercise 12.11,What would happen if we called process as follows? process(shared_ptr<int>(p.get()));,Pointers and Dynamic Memory
Exercise 12.12,"Using the declarations of p and sp explain each of the following calls to process. If the call is legal, explain what it does. If the call is illegal, explain why auto p = new int(); auto sp = make_shared<int>(); aprocesssp); b process(new int()); cprocess(p; (d) process(shared_ptr<int>(p)) ;",Pointers and Dynamic Memory
Exercise 12.13,"What happens if we execute the following code?. auto sp = make_shared<int>(); auto p = sp.get(); delete p;. 12.1.4 Smart Pointers and Exceptions In S 5.6.2 (p. 196) we noted that programs that use exception handling to continue processing after an exception occurs need to ensure that resources are properly freed if an exception occurs. One easy way to make sure resources are freed is to use smart pointers. When we use a smart pointer, the smart pointer class ensures that memory is freed when it is no longer needed even if the block is exited prematurely void f() { I / code that throws an exception that is not caught inside f. }// shared ptr freed automatically when the function ends When a function is exited, whether through normal processing or due to an ex- ception, all the local objects are destroyed. In this case, sp is a shared ptr, so destroying sp checks its reference count. Here, sp is the only pointer to the mem- ory it manages; that memory will be freed as part of destroying sp. In contrast, memory that we manage directly is not automatically freed when an exception occurs. If we use built-in pointers to manage memory and an excep- tion occurs after a new but before the corresponding delete, then that memory won't be freed:",Pointers and Dynamic Memory
Exercise 12.14,Write your own version of a function that uses a shared_ptr to man- age a connection..,Pointers and Dynamic Memory
Exercise 12.15,"Rewrite the first exercise to use a lambda ($ 10.3.2, p. 388) in place of the end_connection function",Pointers and Dynamic Memory
Exercise 12.16,Compilers dont always give easy-to-understand error messages if we. attempt to copy or assign a unique_ptr. Write a program that contains these errors to see how your compiler diagnoses them.,Pointers and Dynamic Memory
Exercise 12.17,"Which of the following unique_pt r declarations are illegal or likely to result in subsequent program error? Explain what the problem is with each one. int ix = 1024, *pi = &ix, *pi2 = new int(2048); typedef unique_ptr<int> IntP; a IntP p0(ix; b IntP pl(pi); (c) IntP p2(pi2); d IntP p3(&ix); (e) IntP p4 (new int(2048)); fIntP p5p2.get);",Pointers and Dynamic Memory
Exercise 12.18,Why doesn't shared_ptr have a release member?.,Pointers and Dynamic Memory
Exercise 12.19,Define your own version of StrB1obPtr and update your StrB1ob class with the appropriate friend declaration and begin and end members.,Pointers and Dynamic Memory
Exercise 12.20,Write a program that reads an input file a line at a time into a St rB1 ob and uses a StrB1obPtr to print each element in that StrBlob..,Pointers and Dynamic Memory
Exercise 12.21,"We could have written StrB1obPtr's deref member as follows: std::string& deref() const {return (*check(curr, ""dereference past end"")) [curr]; } Which version do you think is better and why?",Pointers and Dynamic Memory
Exercise 12.22,"What changes would need to be made to St rB1obPt r to create a class that can be used with a const StrBlob? Define a class named ConstStrBlobPtr that can point to a const StrBlob. 12.2Dynamic Arrays The new and delete operators allocate objects one at a time. Some applications, need the ability to allocate storage for many objects at once. For example, vectors and st rings store their elements in contiguous memory and must allocate several elements at once whenever the container has to be reallocated ($ 9.4, p. 355). To support such usage, the language and library provide two ways to allocate. an array of objects at once. The language defines a second kind of new expression that allocates and initializes an array of objects. The library includes a template class named a1locator that lets us separate allocation from initialization. For reasons well explain in S 12.2.2 (p. 481), using an a11ocator generally provides better performance and more flexible memory management. Many, perhaps even most, applications have no direct need for dynamic arrays When an application needs a varying number of objects, it is almost always easier, faster, and safer to do as we did with StrBlob: use a vector (or other library container). For reasons well explain in S 13.6 (p.531), the advantages of using a li- brary container are even more pronounced under the new standard. Libraries that support the new standard tend to be dramatically faster than previous releases. Best Most applications should use a library container rather than dynami-. Praetices cally allocated arrays. Using a container is easier, less likely to contain memory-management bugs, and is likely to give better performance. As we've seen, classes that use the containers can use the default versions of the operations for copy, assignment, and destruction ($ 7.1.5, p. 267). Classes that allo- cate dynamic arrays must define their own versions of these operations to manage the associated memory when objects are copied, assigned, and destroyed. Do not allocate dynamic arrays in code inside classes until you have read. WARNINGE Chapter 13.",Pointers and Dynamic Memory
Exercise 12.23,"Write a program to concatenate two string literals, putting the result in a dynamically allocated array of char. Write a program to concatenate two library strings that have the same value as the literals used in the first program.",Pointers and Dynamic Memory
Exercise 12.24,Write a program that reads a string from the standard input into a dynamically allocated character array. Describe how your program handles varying size inputs. Test your program by giving it a string of data that is longer than the array size you've allocated.,Pointers and Dynamic Memory
Exercise 12.25,"Given the following new expression, how would you delete pa?. int *pa = new int [lo];",Pointers and Dynamic Memory
Exercise 12.26,"Rewrite the program on page 481 using an a11ocator. 12.3 Using the Library: A Text-Query Program To conclude our discussion of the library, we'll implement a simple text-query pro- gram. Our program will let a user search a given file for words that might occur in it. The result of a query will be the number of times the word occurs and a list of lines on which that word appears. If a word occurs more than once on the same line, well display that line only once. Lines will be displayed in ascending order-that is, line 7 should be displayed before line 9, and so on. For example, we might read the file that contains the input for this chapter and look for the word e1ement. The first few lines of the output would be element occurs 112 times (line 36) A set element contains only a key; (line 158) operator creates a new element (line 160) Regardless of whether the element (line l68) When we fetch an element from a map, we (line 2l4) If the element is not found, find returns followed by the remaining 100 or so lines in which the word e1ement occurs.",Pointers and Dynamic Memory
Exercise 12.27,"The TextQuery and QueryResult classes use only capabilities that we have already covered. Without looking ahead, write your own versions of these. classes.",Pointers and Dynamic Memory
Exercise 12.28,"Write a program to implement text queries without defining classes to manage the data. Your program should take a file and interact with a user to query for words in that file. Use vector, map, and set containers to hold the data for the file and to generate the results for the queries..",Pointers and Dynamic Memory
Exercise 12.29,"We could have written the loop to manage the interaction with the user as a do whi1e ($ 5.4.4, p. 189) loop. Rewrite the loop to use a do whi1e. Explain which version you prefer and why.. 12.3.2Defining the Query Program Classes Well start by defining our TextQuery class. The user will create objects of this class by supplying an ist ream from which to read the input file. This class also provides the query operation that will take a string and return a QueryResult representing the lines on which that string appears.. The data members of the class have to take into account the intended sharing with QueryResult objects. The QueryResult class will share the vector repre. senting the input file and the sets that hold the line numbers associated with each word in the input. Hence, our class has two data members: a shared ptr to a. dynamically allocated vector that holds the input file, and a map from st ring to shared ptr<set >. The map associates each word in the file with a dynamically. allocated set that holds the line numbers on which that word appears. To make our code a bit easier to read, well also define a type member ($ 7.3.1, p. 271) to refer to line numbers, which are indices into a vector of strings: class QueryResult; / / declaration needed for return type in the query function class TextQuery { public: using line_no = std::vector<std::string>::size_type; TextQuery(std::ifstream&) ; QueryResult query(const std::string&) const; private: std::shared_ptr<std::vector<std::string>> file; // inputfile / /  map of each word to the set of the lines in which that word appears std::map<std::string, std::shared_ptr<std::set<line_no>>> wm; } ;",Pointers and Dynamic Memory
Exercise 12.30,Define your own versions of the TextQuery and QueryResult classes and execute the runQueries function from $ 12.3.1 (p. 486),Pointers and Dynamic Memory
Exercise 12.31,What difference(s) would it make if we used a vector instead of a set to hold the line numbers? Which approach is better? Why?,Pointers and Dynamic Memory
Exercise 12.32,Rewrite the TextQuery and QueryResult classes to use a StrBlob instead of a vector<string> to hold the input file.,Pointers and Dynamic Memory
Exercise 12.33,"In Chapter 15 well extend our query system and will need some addi tional members in the QueryResu1t class. Add members named begin and end that return iterators into the set of line numbers returned by a given query, and a member named get_file that returns a shared_ptr to the file in the QueryResult object.",Pointers and Dynamic Memory
Exercise 13.1,What is a copy constructor? When is it used?,Copy Control
Exercise 13.2,Explain why the following declaration is illegal Sales_data::Sales_data(Sales_data rhs);,Copy Control
Exercise 13.3,What happens when we copy a StrBlob? What about StrBlobPtrs?,Copy Control
Exercise 13.4,"Assuming Point is a class type with a publi c copy constructor, iden- tify each use of the copy constructor in this program fragment: Point global; Point foo_bar(Point arg) Point local = arg, *heap = new Point(global); *heap = local; Point pa[4 ] = {local, *heap }; return *heap; }",Copy Control
Exercise 13.5,"Given the following sketch of a class, write a copy constructor that copies all the members. Your constructor should dynamically allocate a new string class HasPtr { public: HasPtr(const std::string &s = std::string()): ps(new std::strings)),i(0){} private: std::string *ps; int i; } ;",Copy Control
Exercise 13.6,What is a copy-assignment operator?When is this operator used? What does the synthesized copy-assignment operator do? When is it synthesized?,Copy Control
Exercise 13.7,What happens when we assign one StrB1ob to another? What about StrBlobPtrs?,Copy Control
Exercise 13.8,"Write the assignment operator for the HasPtr class from exercise 13.5 in $ 13.1.1 (p. 499). As with the copy constructor, your assignment operator should copy the object to which ps points. 13.1.3The Destructor The destructor operates inversely to the constructors: Constructors initialize the nonstatic data members of an object and may do other work; destructors dc whatever work is needed to free the resources used by an object and destroy the nonstatic data members of the object. The destructor is a member function with the name of the class prefixed by a tilde (~). It has no return value and takes no parameters: class Foo { public: ~FoO); //destructor // }; Because it takes no parameters, it cannot be overloaded. There is always only one destructor for a given class. What a Destructor Does Just as a constructor has an initialization part and a function body ($ 7.5.1, p. 288) a destructor has a function body and a destruction part. In a constructor, members are initialized before the function body is executed, and members are initialized",Copy Control
Exercise 13.9,What is a destructor? What does the synthesized destructor do? When is a destructor synthesized?,Copy Control
Exercise 13.10,What happens when a StrB1ob object is destroyed? What about a StrBlobPtr?,Copy Control
Exercise 13.11,Add a destructor to your HasPtr class from the previous exercises.,Copy Control
Exercise 13.12,"How many destructor calls occur in the following code fragment? bool fcn(const Sales_data +trans, Sales_data accum) Sales_data iteml(*trans), item2(accum); return iteml.isbn() != item2.isbn();",Copy Control
Exercise 13.13,"A good way to understand copy-control members and constructors is to define a simple class with these members in which each member prints its name: struct X { X){std:cout <<""x)<< std:endl} Xconst X&){std::cout << ""Xconst X&) << std::endl;} }; Add the copy-assignment operator and destructor to X and write a program using X objects in various ways: Pass them as nonreference and reference parameters; dynam- ically allocate them; put them in containers; and so forth. Study the output until you are certain you understand when and why each copy-control member is used. As you read the output, remember that the compiler can omit calls to the copy constructor. There is no requirement that we define all of these operations: We can define one or two of them without having to define all of them. However, ordinarily these operations should be thought of as a unit. In general, it is unusual to need one without needing to define them all. Classes That Need Destructors Need Copy and Assignment One rule of thumb to use when you decide whether a class needs to define its own versions of the copy-control members is to decide first whether the class needs a destructor. Often, the need for a destructor is more obvious than the need for the copy constructor or assignment operator. If the class needs a destructor, it almost surely needs a copy constructor and copy-assignment operator as well. The Has Pt r class that we have used in the exercises is a good example ($ 13.1.1, p. 499). That class allocates Pointers and Dynamic Memory in its constructor. The synthesized destructor will not delete a data member that is a pointer. Therefore, this class needs to define a destructor to free the memory allocated by its constructor. What may be less clearbut what our rule of thumb tells usis that HasPt r also needs a copy constructor and copy-assignment operator.",Copy Control
Exercise 13.14,"Assume that numbered is a class with a default constructor that gen- erates a unique serial number for each object, which is stored in a data member named mysn. Assuming numbered uses the synthesized copy-control members and given the following function: void f numbered s) { cout << s.mysn << endl; } what output does the following code produce? numbered a,b=a, c=b; fa;fbfc;",Copy Control
Exercise 13.15,"Assume numbered has a copy constructor that generates a new serial number. Does that change the output of the calls in the previous exercise? If so, why? What output gets generated?",Copy Control
Exercise 13.16,"What if the parameter in f were const numbered&? Does that change the output? If so, why? What output gets generated?",Copy Control
Exercise 13.17,"Write versions of numbered and f corresponding to the previous three exercises and check whether you correctly predicted the output. 13.1.5 Using = default We can explicitly ask the compiler to generate the synthesized versions of the copy-control members by defining them as = de f au1t (S 7.1.4, p. 264): class Sales_data { public: //copy control; use defaults Sales_data() = default; Sales_data(const Sales_data&) = default; Sales_data& operator=(const Sales_data &) ; ~Sales_data() = default; I/other members as before 1{ Sales_data& Sales_data::operator=(const Sales_data&) = default; When we specify = default on the declaration of the member inside the class body, the synthesized function is implicitly inline (just as is any other member",Copy Control
Exercise 13.18,Define an Employee class that contains an employee name and a unique employee identifier. Give the class a default constructor and a constructor that takes a string representing the employee's name. Each constructor should generate a unique ID by incrementing a static data member.,Copy Control
Exercise 13.19,"Does your Employee class need to define its own versions of the copy-control members? If so, why? If not, why not? Implement whatever copy-control. members you think Empl oyee needs.",Copy Control
Exercise 13.20,"Explain what happens when we copy, assign, or destroy objects of our TextQuery and QueryResult classes from  12.3 (p. 484).",Copy Control
Exercise 13.21,"Do you think the TextQuery and QueryResult classes need to de- fine their own versions of the copy-control members? If so, why? If not, why not? Implement whichever copy-control operations you think these classes require. 13.2 Copy Control and Resource Management Ordinarily, classes that manage resources that do not reside in the class must define the copy-control members. As we saw in S 13.1.4 (p. 504), such classes will need destructors to free the resources allocated by the object. Once a class needs a de- as well. In order to define these members, we first have to decide what copying an object of our type will mean. In general, we have two choices: We can define the copy operations to make the class behave like a value or like a pointer. Classes that behave like values have their own state. When we copy a valuelike object, the copy and the original are independent of each other. Changes made to the copy have no effect on the original, and vice versa.. Classes that act like pointers share state. When we copy objects of such classes, the copy and the original use the same underlying data. Changes made to the copy also change the original, and vice versa. Of the library classes we've used, the library containers and st ring class have valuelike behavior. Not surprisingly, the shared_ptr class provides pointer- like behavior, as does our StrBlob class (S 12.1.1, p. 456). The IO types and",Copy Control
Exercise 13.22,"Assume that we want HasPtr to behave like a value. That is, each object should have its own copy of the string to which the objects point. Well show the definitions of the copy-control members in the next section. However, you already know everything you need to know to implement these members. Write the HasPtr. copy constructor and copy-assignment operator before reading on. 13.2.1  Classes That Act Like Values To provide valuelike behavior, each object has to have its own copy of the resource that the class manages. That means each HasPt r object must have its own copy of the string to which ps points. To implement valuelike behavior HasPtr needs A copy constructor that copies the string, not just the pointer A destructor to free the string A copy-assignment operator to free the object's existing string and copy. the string from its right-hand operand The valuelike version of HasPtr is class HasPtr { public: HasPtr(const std::string &s = std::string()): ps(new std::string(s)),i(0) {} // each HasPtr has its own copy of the string to which ps points HasPtr(const HasPtr &p): ps(new std::string*p.ps)),ip.i){} HasPtr& operator=(const HasPtr &); ~HasPtr() {delete ps; } private: std::string *ps; int i; };",Copy Control
Exercise 13.23,"Compare the copy-control members that you wrote for the solutions to the previous section's exercises to the code presented here. Be sure you understand. the differences, if any, between your code and ours.",Copy Control
Exercise 13.24,What would happen if the version of HasPtr in this section didn't define a destructor? What if HasPtr didn't define the copy constructor?,Copy Control
Exercise 13.25,Assume we want to define a version of St rB1 ob that acts like a value. Also assume that we want to continue to use a shared_ptr so that our StrB1obPtr class can still use a weak_ptr to the vector. Your revised class will need a copy constructor and copy-assignment operator but will not need a destructor. Explain what the copy constructor and copy-assignment operators must do. Explain why the class does not need a destructor.,Copy Control
Exercise 13.26,"Write your own version of the StrB1ob class described in the previ- ous exercise. 13.2.2 Defining Classes That Act Like Pointers For our HasPtr class to act like a pointer, we need the copy constructor and copy- assignment operator to copy the pointer member, not the string to which that pointer points. Our class will still need its own destructor to free the memory allocated by the constructor that takes a string (S 13.1.4, p. 504). In this case, though, the destructor cannot unilaterally free its associated string. It can do so only when the last HasPtr pointing to that string goes away. The easiest way to make a class act like a pointer is to use shared ptrs to. manage the resources in the class. Copying (or assigning) a shared_ptr copies",Copy Control
Exercise 13.27,Define your own reference-counted version of Has Ptr..,Copy Control
Exercise 13.28,"Given the following classes, implement a default constructor and the. necessary copy-control members. (a) class TreeNode { (b) class BinStrTree { private: private: std::string value; TreeNode *root; int count; !{ TreeNode +left; TreeNode *right; 1{ 13.3Swap In addition to defining the copy-control members, classes that manage resources. often also define a function named swap (S 9.2.5, p. 339). Defining swap is par- ticularly important for classes that we plan to use with algorithms that reorder. elements (S 10.2.3,p.383).Such algorithms call swap whenever they need to ex change two elements. If a class defines its own swap, then the algorithm uses that class-specific ver-. sion. Otherwise, it uses the swap function defined by the library. Although, as usual, we don't know how swap is implemented, conceptually it's easy to see that swapping two objects involves a copy and two assignments. For example, code to swap two objects of our valuelike HasPtr class (S 13.2.1, p. 511) might look something like: HasPtr temp = v1; //make a temporary copy of the value of v1 vl = v2; // assign the value of v2 to v1 v2 =temp; //assign the saved value of v1 to v2",Copy Control
Exercise 13.29,"Explain why the calls to swap inside swap (HasPtr&, HasPtr&) do not cause a recursion loop,",Copy Control
Exercise 13.30,Write and test a swap function for your valuelike version of HasPtr. Give your swap a print statement that notes when it is executed.,Copy Control
Exercise 13.31,Give your class a < operator and define a vector of HasPtrs. Give that vector some elements and then sort the vector. Note when swap is called.,Copy Control
Exercise 13.32,"Would the pointerlike version of HasPt r benefit from defining a swap function? If so, what is the benefit? If not, why not?. 13.4 A Copy-Control Example Although copy control is most often needed for classes that allocate resources, re- source management is not the only reason why a class might need to define these members. Some classes have bookkeeping or other actions that the copy-control members must perform As an example of a class that needs copy control in order to do some bookkeep. ing, we'll sketch out two classes that might be used in a mail-handling application. These classes, Mes sage and Folder, represent, respectively, email (or other kinds",Copy Control
Exercise 13.33,Why is the parameter to the save and remove members of Message a Folder&? Why didn't we define that parameter as Folder? Or const Folder&?,Copy Control
Exercise 13.34,Write the Message class as described in this section.,Copy Control
Exercise 13.35,What would happen if Message used the synthesized versions of the copy-control members?,Copy Control
Exercise 13.36,Design and implement the corresponding Fo1der class. That class should hold a set that points to the Messages in that Folder.,Copy Control
Exercise 13.37,Add members to the Message class to insert or remove a given Folder+ into folders. These members are analogous to Folder's addMsg and remMsg operations.,Copy Control
Exercise 13.38,"We did not use copy and swap to define the Message assignment operator. Why do you suppose this is so? 13.5 Classes That Manage Pointers and Dynamic Memory Some classes need to allocate a varying amount of storage at run time. Such classes data. For example, our StrBlob class uses a vector to manage the underlying. storage for its elements. However, this strategy does not work for every class; some classes need to do their own allocation. Such classes generally must define their own copy-control. members to manage the memory they allocate.",Copy Control
Exercise 13.39,"Write your own version of StrVec, including versions of reserve, capacity (S9.4, p. 356), and resize ($9.3.5, p. 352) Exercise13.40: Add a constructor that takes an initializer_list<string> to your StrVec class.",Copy Control
Exercise 13.41,Why did we use postfix increment in the call to construct inside push_back? What would happen if it used the prefix increment?,Copy Control
Exercise 13.42,"Test your StrVec class by using it in place of the vector<string> in your TextQuery and QueryResult classes ($ 12.3, p. 484).",Copy Control
Exercise 13.43,"Rewrite the free member to use for_each and a lambda (S 10.3.2 p. 388) in place of the for loop to destroy the elements. Which implementation do you prefer, and why?",Copy Control
Exercise 13.44,"Write a class named St ring that is a simplified version of the library string class. Your class should have at least a default constructor and a constructor that takes a pointer to a C-style string. Use an a1locator to allocate memory that. your string class uses. 13.6Moving Objects One of the major features in the new standard is the ability to move rather than copy an object. As we saw in S 13.1.1 (p. 497), copies are made in many circum- stances. In some of these circumstances, an object is immediately destroyed after it is copied. In those cases, moving, rather than copying, the object can provide a significant performance boost. As we've just seen, our StrVec class is a good example of this kind of super fluous copy. During reallocation, there is no need to copyrather than move-the. elements from the old memory to the new. A second reason to move rather than copy occurs in classes such as the IO or unique_pt r classes. These classes have a resource (such as a pointer or an IO buffer) that may not be shared. Hence, objects of these types can't be copied but can be moved..",Copy Control
Exercise 13.45,Distinguish between an rvalue reference and an lvalue reference.,Copy Control
Exercise 13.46,Which kind of reference can be bound to the following initializers? int f; vector<int> vi(100); int? rl =f(); int? r2 = vi[0]; int? r3 =rl; int? r4 = vi[0] * f;,Copy Control
Exercise 13.47,Give the copy constructor and copy-assignment operator in your String class from exercise 13.44 in  13.5 (p. 531) a statement that prints a message each time the function is executed.,Copy Control
Exercise 13.48,"Define a vector<String> and call push_back several times on that vector. Run your program and see how often Strings are copied. 13.6.2Move Constructor and Move Assignment Like the st ring class (and other library classes), our own classes can benefit from being able to be moved as well as copied. To enable move operations for our own types, we define a move constructor and a move-assignment operator. These mem- bers are similar to the corresponding copy operations, but they ""steal resources from their given object rather than copy them. C++ Like the copy constructor, the move constructor has an initial parameter that is a reference to the class type. Differently from the copy constructor, the reference parameter in the move constructor is an rvalue reference. As in the copy construc- tor, any additional parameters must all have default arguments. In addition to moving resources, the move constructor must ensure that the moved-from object is left in a state such that destroying that object will be harm- less. In particular, once its resources are moved, the original object must no longer point to those moved resources-responsibility for those resources has been as- sumed by the newly created object.",Copy Control
Exercise 13.49,"Add a move constructor and move-assignment operator to your StrVec, String, and Message classes..",Copy Control
Exercise 13.50,Put print statements in the move operations in your Str ing class and rerun the program from exercise 13.48 in  13.6.1 (p. 534) that used a vector<St ring> to see when the copies are avoided..,Copy Control
Exercise 13.51,"Although unique_ptrs cannot be copied, in S 12.1.5 (p.471) we wrote a clone function that returned a unique_pt r by value. Explain why that func- tion is legal and how it works.",Copy Control
Exercise 13.52,"Explain in detail what happens in the assignments of the HasPt r ob- jects on page 541. In particular, describe step by step what happens to values of hp,. hp2, and of the rhs parameter in the HasPtr assignment operator..",Copy Control
Exercise 13.53,"As a matter of low-level efficiency, the HasPt r assignment operator is not ideal. Explain why. Implement a copy-assignment and move-assignment oper- ator for HasPtr and compare the operations executed in your new move-assignment operator versus the copy-and-swap version..",Copy Control
Exercise 13.54,What would happen if we defined a HasPt r move-assignment oper ator but did not change the copy-and-swap operator? Write code to test your answer. 13.6.3 Rvalue References and Member Functions Member functions other than constructors and assignment can benefit from pro viding both copy and move versions. Such move-enabled members typically use,Copy Control
Exercise 13.55,Add an rvalue reference version of push_back to your StrB1ob,Copy Control
Exercise 13.56,What would happen if we defined sorted as:. Foo Foo::sorted() const & Foo ret(this); return ret.sorted(); },Copy Control
Exercise 13.57,What if we defined sorted as: Foo Foo::sorted() const & {return Foo(*this).sorted(); },Copy Control
Exercise 13.58,Write versions of class Foo with print statements in their sorted functions to test your answers to the previous two exercises.,Copy Control
Exercise 14.1,In what ways does an overloaded operator differ from a built-in opera- tor? In what ways are overloaded operators the same as the built-in operators?,Operator Overloading
Exercise 14.2,"Write declarations for the overloaded input, output, addition, and compound-assignment operators for Sales_data.",Operator Overloading
Exercise 14.3,"Both string and vector define an overloaded == that can be used to compare objects of those types. Assuming svec1 and svec2 are vectors that hold strings, identify which version of == is applied in each of the following expressions: a""cobble"" ==""stone"" b) svec1[0] == svec2 [0] c) svecl == svec2 dsvecl [0] ==""stone""",Operator Overloading
Exercise 14.4,Explain how to decide whether the following should be class members: a b= c++ d-> (e<< f&& g== (h),Operator Overloading
Exercise 14.5,"In exercise 7.40 from  7.5.1 (p. 291) you wrote a sketch of one of the following classes. Decide what, if any, overloaded operators your class should provide. aBook bDate (c) Employee (d) Vehicle (e Object (f) Tree 14.2 Input and Output Operators As we've seen, Streams and IO Library uses >> and << for input and output, respectively Streams and IO Library itself defines versions of these operators to read and write the built- in types. Classes that support IO ordinarily define versions of these operators for. objects of the class type",Operator Overloading
Exercise 14.6,Define an output operator for your Sales_data class,Operator Overloading
Exercise 14.7,Define an output operator for you String class you wrote for the ex ercises in  13.5 (p. 531).,Operator Overloading
Exercise 14.8,"Define an output operator for the class you chose in exercise 7.40 from. S 7.5.1 (p. 291). 14.2.2 Overloading the Input Operator >> Ordinarily the first parameter of an input operator is a reference to the stream from which it is to read, and the second parameter is a reference to the (nonconst) object into which to read. The operator usually returns a reference to its given. stream. The second parameter must be nonconst because the purpose of an input operator is to read data into this object.. The Sales_data Input Operator As an example, well write the Sales data input operator. istream &operator>>(istream &is, Sales_data &item) double price ; I / no need to initialize; we'll read into price before we use it. is >> item.bookNo >> item.units_sold >> price; if (is) 1/check that the inputs succeeded item.revenue = item.units_sold * price; else item = Sales_data () ; // input failed: give the object the default state return is; A Except for the if statement, this definition is similar to our earlier read function (S 7.1.3, p. 261). The i f checks whether the reads were successful. If an IO error the object is guaranteed to be in a consistent state. Note Input operators must deal with the possibility that the input might fail;. output operators generally don't bother..",Operator Overloading
Exercise 14.9,Define an input operator for your Sales_data class..,Operator Overloading
Exercise 14.10,Describe the behavior of the Sales_data input operator if given the following input:. (a 0-201-99999-9 10 24.95 (b) 10 24.95 0-210-99999-9,Operator Overloading
Exercise 14.11,"What, if anything, is wrong with the following Sales_data input op- erator? What would happen if we gave this operator the data in the previous exercise? istream& operator>>(istream& in, Sales_data& s) double price; in >> s.bookNo >> s.units_sold >> price; s.revenue = s.units_sold * price; return in;",Operator Overloading
Exercise 14.12,"Define an input operator for the class you used in exercise 7.40 from 7.5.1 (p. 291). Be sure the operator handles input errors. 14.3 Arithmetic and Relational Operators Ordinarily, we define the arithmetic and relational operators as nonmember func- tions in order to allow conversions for either the left- or right-hand operand ($ 14.1 p. 555). These operators shouldn't need to change the state of either operand, so the parameters are ordinarily references to const. An arithmetic operator usually generates a new value that is the result of a computation on its two operands. That value is distinct from either operand and is calculated in a local variable. The operation returns a copy of this local as its result Classes that define an arithmetic operator generally define the corresponding com- pound assignment operator as well. When a class has both operators, it is usually more efficient to define the arithmetic operator to use compound assignment:. I/assumes that both objects refer to the same book Sales_data. operator+(const Sales_data &lhs, const Sales_data &rhs) Sales_data sum = lhs; / / copy data members from Ihs into sum sum += rhs; // add rhs into sum return sum; This definition is essentially identical to our original add function (S 7.1.3, p. 261). We copy 1hs into the local variable sum. We then use the Sales_data compound-assignment operator (which well define on page 564) to add the values from rhs into sum. We end the function by returning a copy of sum.",Operator Overloading
Exercise 14.13,"Which other arithmetic operators (Table 4.1 (p. 139), if any, do you think Sales_dat a ought to support? Define any you think the class should include.",Operator Overloading
Exercise 14.14,Why do you think it is more efficient to define operator+ to call operator+= rather than the other way around?,Operator Overloading
Exercise 14.15,"Should the class you chose for exercise 7.40 from  7.5.1 (p. 291) define any of the arithmetic operators? If so, implement them. If not, explain why not. 14.3.1Equality Operators Ordinarily, classes in C++ define the equality operator to test whether two objects objects as equal if and only if all the corresponding members are equal. In line with this design philosophy, our Sales_data equality operator should compare the bookNo as well as the sales figures: bool operator==(const Sales_data &lhs, const Sales_data &rhs) return lhs.isbn() == rhs.isbn() && lhs.units_sold == rhs.units_sold && lhs.revenue == rhs.revenue; bool operator!=(const Sales data &lhs, const Sales data &rhs) return I(lhs == rhs); } The definition of these functions is trivial. More important are the design princi- ples that these functions embody: If a class has an operation to determine whether two objects are equal, it should define that function as operator== rather than as a named function: Users will expect to be able to compare objects using = =; providing == means they won't need to learn and remember a new name for the operation; and it is easier to use the library containers and algorithms with classes that define the == operator. If a class defines operator==, that operator ordinarily should determine whether the given objects contain equivalent data.",Operator Overloading
Exercise 14.16,"Define equality and inequality operators for your St rB1ob (S 12.1.1 p. 456), StrB1obPtr (S12.1.6, p.474), StrVec (S 13.5, p. 526), and String (S 13.5, p. 531) classes.",Operator Overloading
Exercise 14.17,"Should the class you chose for exercise 7.40 from  7.5.1 (p. 291) define the equality operators? If so, implement them. If not, explain why not. 14.3.2 Relational Operators Classes for which the equality operator is defined also often (but not always) have relational operators. In particular, because the associative containers and some of. the algorithms use the less-than operator, it can be useful to define an operator< Ordinarily the relational operators should 1. Define an ordering relation that is consistent with the requirements for use as a key to an associative container (S 11.2.2, p.424); and 2. Define a relation that is consistent with == if the class has both operators. In particular, if two objects are ! =, then one object should be < the other. Although we might think our Sales data class should support the relational operators, it turns out that it probably should not do so. The reasons are subtle and are worth understanding. We might think that wed define < similarly to compare I sbn ($ 11.2.2, p. 425) That function compared Sales_dat a objects by comparing their IsBNs. Although. compareIsbn provides an ordering relation that meets requirment 1, that func tion yields results that are inconsistent with our definition of ==. As a result, it does not meet requirement 2. The Sales_data == operator treats two transactions with the same ISBN as unequal if they have different revenue or units sold members. If we defined.",Operator Overloading
Exercise 14.18,"Define relational operators for your StrBlob, StrBlobPtr, StrVec, and String classes..",Operator Overloading
Exercise 14.19,"Should the class you chose for exercise 7.40 from  7.5.1 (p. 291) define the relational operators? If so, implement them. If not, explain why not 14.4Assignment Operators In addition to the copy- and move-assignment operators that assign one object of the class type to another object of the same type S 13.1.2, p.500, and S 13.6.2 p. 536), a class can define additional assignment operators that allow other types as the right-hand operand. As one example, in addition to the copy- and move-assignment operators, the. library vector class defines a third assignment operator that takes a braced list of elements (S 9.2.5, p. 337). We can use this operator as follows: vector<string> v; v={a,""an,""the}; We can add this operator to our St rVec class (S 13.5, p. 526) as well: class StrVec { public: StrVec &operator=(std::initializer_list<std::string>); //other members as in  13.5 (p. 526) } ;",Operator Overloading
Exercise 14.20,Define the addition and compound-assignment operators for your Sales_data class..,Operator Overloading
Exercise 14.21,Write the Sales_data operators so that + does the actual addition and += calls +. Discuss the disadvantages of this approach compared to the way these operators were defined in $ 14.3 (p. 560) and $ 14.4 (p. 564).,Operator Overloading
Exercise 14.22,Define a version of the assignment operator that can assign a st ring. representing an ISBN to a Sales_data.,Operator Overloading
Exercise 14.23,Define an initiali zer_1ist assignment operator for your version of the StrVec class..,Operator Overloading
Exercise 14.24,"Decide whether the class you used in exercise 7.40 from $ 7.5.1 (p. 291) needs a copy- and move-assignment operator. If so, define those operators.",Operator Overloading
Exercise 14.25,"Implement any other assignment operators your class should define. Explain which types should be used as operands and why.. Note The subscript operator must be a member function To be compatible with the ordinary meaning of subscript, the subscript op-. erator usually returns a reference to the element that is fetched. By returning a reference, subscript can be used on either side of an assignment. Consequently, it. is also usually a good idea to define both const and nonconst versions of this operator. When applied to a const object, subscript should return a reference to const so that it is not possible to assign to the returned object. Best If a class has a subscript operator, it usually should define two versions: Practices one that returns a plain reference and the other that is a const member and returns a reference to const. As an example, well define subscript for St rVec (S 13.5, p. 526): class StrVec { public: std::string& operator[] (std::size_t n) {return elements[n]; } const std::string& operator[](std::size_t n) const {return elements[n]; } /other members as in 13.5 (p. 526) private: std::string *elements; 1/pointer to the first element in the array. !{ We can use these operators similarly to how we subscript a vector or array Because subscript returns a reference to an element, if the StrVec is nonconst, we can assign to that element; if we subscript a const object, we cant:",Operator Overloading
Exercise 14.26,"Define subscript operators for your StrVec, String, StrB1ob, and StrBlobPtr classes. 14.6Increment and Decrement Operators The increment (++) and decrement (- -) operators are most often implemented for iterator classes. These operators let the class move between the elements of a se- quence. There is no language requirement that these operators be members of the. class. However, because these operators change the state of the object on which they operate, our preference is to make them members. For the built-in types, there are both prefix and postfix versions of the incre- ment and decrement operators. Not surprisingly, we can define both the prefix and postfix instances of these operators for our own classes as well. Well look at the prefix versions first and then implement the postfix ones.. Best Classes that define increment or decrement operators should define. Praetices both the prefix and postfix versions. These operators usually should be defined as members. Defining Prefix Increment/Decrement Operators To illustrate the increment and decrement operators, well define these operators for our St rB1obPtr class (S 12.1.6, p. 474) class StrBlobPtr { public: //increment and decrement StrBlobPtr& operator++() ; //prefix operators StrBlobPtr& operator--(); //other members as before }; Best To be consistent with the built-in operators, the prefix operators should Praetiees return a reference to the incremented or decremented object",Operator Overloading
Exercise 14.27,Add increment and decrement operators to your StrB1obPtr class.,Operator Overloading
Exercise 14.28,"Define addition and subtraction for StrB1obPt r so that these opera- tors implement pointer arithmetic ($ 3.5.3, p. 119).",Operator Overloading
Exercise 14.29,"We did not define a const version of the increment and decrement. Operators. Why not? 14.7 Member Access Operators The dereference (*) and arrow (->) operators are often used in classes that rep resent iterators and in smart pointer classes ($ 12.1, p. 450). We can logically add these operators to our StrB1obPtr class as well: class StrBlobPtr { public: std::string& operator*() const {auto p = check(curr, ""dereference past end""); return (*p) [curr];// (*p) is the vector to which this object points std::string* operator->() const {/ /delegate the real work to the dereference operator return & this->operator*(); other members as before }; The dereference operator checks that curr is still in range and, if so, returns a reference to the element denoted by curr. The arrow operator avoids doing any work of its own by calling the dereference operator and returning the address of the element returned by that operator. Note Operator arrow must be a member. The dereference operator is not re- quired to be a member but usually should be a member as well. It is worth noting that we've defined these operators as const members. Un- like the increment and decrment operators, fetching an element doesn't change the state of a St rBlobPtr. Also note that these operators return a reference or pointer. to nonconst string. They do so because we know that a StrBlobPtr can only. be bound to a nonconst StrB1ob (S 12.1.6, p. 474) We can use these operators the same way that we've used the corresponding operations on pointers or vector iterators: StrBlob al={""hi"",""bye,""now""}; StrBlobPtr p(al); // p points to the vector inside al *p=""okay""; // assigns to the first element in al cout << p->size() << endl; //prints 4, the size of the first element in a1 cout << *p).size) << endl;// equivalenttop->size)",Operator Overloading
Exercise 14.30,Add dereference and arrow operators to your StrB1obPtr class and to the Const St rB1obPt r class that you defined in exercise 12.22 from S 12.1.6 (p. 476). Note that the operators in constStrB1obPtr must return const references because the data member in constStrBlobPtr points to a const vector..,Operator Overloading
Exercise 14.31,"Our StrB1obPtr class does not define the copy constructor, assign-. ment operator, or a destructor. Why is that okay?",Operator Overloading
Exercise 14.32,Define a class that holds a pointer to a St rB1obPtr. Define the over- loaded arrow operator for that class.,Operator Overloading
Exercise 14.33,How many operands may an overloaded function-call operator take?,Operator Overloading
Exercise 14.34,"Define a function-object class to perform an if-then-else operation: The call operator for this class should take three parameters. It should test its first parame- ter and if that test succeeds, it should return its second parameter; otherwise, it should return its third parameter.",Operator Overloading
Exercise 14.35,"Write a class like PrintString that reads a line of input from an istream and returns a string representing what was read. If the read fails, return the empty string.",Operator Overloading
Exercise 14.36,"Use the class from the previous exercise to read the standard input, storing each line as an element in a vector..",Operator Overloading
Exercise 14.37,"Write a class that tests whether two values are equal. Use that object and the library algorithms to write a program to replace all instances of a given value in a sequence. 14.8.1Lambdas Are Function Objects In the previous section, we used a PrintString object as an argument in a call. to for_each. This usage is similar to the programs we wrote in $ 10.3.2 (p. 388) that used lambda expressions. When we write a lambda, the compiler translates",Operator Overloading
Exercise 14.38,Write a class that tests whether the length of a given string matches a given bound. Use that object to write a program to report how many words in an input file are of sizes 1 through 10 inclusive.,Operator Overloading
Exercise 14.39,Revise the previous program to report the count of words that are sizes 1 through 9 and 10 or more.,Operator Overloading
Exercise 14.40,Rewrite the biggi es function from $ 10.3.2 (p. 391) to use function- object classes in place of lambdas.,Operator Overloading
Exercise 14.41,"Why do you suppose the new standard added lambdas? Explain when you would use a lambda and when you would write a class instead. 14.8.2Library-Defined Function Objects The standard library defines a set of classes that represent the arithmetic, relational, and logical operators. Each class defines a call operator that applies the named operation. For example, the plus class has a function-call operator that applies + to a pair of operands; the modulus class defines a call operator that applies the binary % operator; the equa1 to class applies ==; and so on. These classes are templates to which we supply a single type. That type speci- fies the parameter type for the call operator. For example, plus<string> applies the string addition operator to string objects; for plus<int > the operands are ints;plus<Sales data> applies + to Sales datas;and soon:",Operator Overloading
Exercise 14.42,"Using library function objects and adaptors, define an expression to (a) Count the number of values that are greater than 1024 (b) Find the first string that is not equal to pooh. (c) Multiply all values by 2",Operator Overloading
Exercise 14.43,"Using library function objects, determine whether a given int value is divisible by any element in a container of ints. 14.8.3 Callable Objects and function C++ has several kinds of callable objects: functions and pointers to functions, lamb das (S 10.3.2, p. 388), objects created by bind (S 10.3.4, p. 397), and classes that overload the function-call operator. Like any other object, a callable object has a type. For example, each lambda has its own unique (unnamed) class type. Function and function-pointer types vary by their return type and argument types, and so on. However, two callable objects with different types may share the same call sig- nature. The call signature specifies the type returned by a call to the object and the argument type(s) that must be passed in the call. A call signature corresponds to a function type. For example: int(int, int) is a function type that takes two ints and returns an int. Different Types Can Have the Same Call Signature Sometimes we want to treat several callable objects that share a call signature as if they had the same type. For example, consider the following different types of callable objects: //ordinary function int add(int i, int j) { return i + j; } J /lambda, which generates an unnamed function-object class auto mod = []int i, int j {return i % j;}; //function-object class struct divide { int operator() (int denominator, int divisor) { return denominator / divisor; !{",Operator Overloading
Exercise 14.44,"Write your own version of a simple desk calculator that can handle binary operations. 14.9 Overloading, Conversions, and Operators In $ 7.5.4 (p. 294) we saw that a nonexp1icit constructor that can be called with one argument defines an implicit conversion. Such constructors convert an object from the argument's type to the class type. We can also define conversions from the class type. We define a conversion from a class type by defining a conversion",Operator Overloading
Exercise 14.45,Write conversion operators to convert a Sales_data to string and to double. What values do you think these operators should return?,Operator Overloading
Exercise 14.46,Explain whether defining these Sa1es_data conversion operators is a good idea and whether they should be explicit..,Operator Overloading
Exercise 14.47,Explain the difference between these two conversion operators: struct Integral { operator const int(); operator int() const; 1{,Operator Overloading
Exercise 14.48,"Determine whether the class you used in exercise 7.40 from $ 7.5.1 (p. 291) should have a conversion to boo1. If so, explain why, and explain whether the operator should be expli cit. If not, explain why not..",Operator Overloading
Exercise 14.49,"Regardless of whether it is a good idea to do so, define a conversion to boo1 for the class from the previous exercise. 14.9.2Avoiding Ambiguous Conversions If a class has one or more conversions, it is important to ensure that there is only one way to convert from the class type to the target type. If there is more than one way to perform a conversion, it will be hard to write unambiguous code. There are two ways that multiple conversion paths can occur. The first happens when two classes provide mutual conversions. For example, mutual conversions exist when a class A defines a converting constructor that takes an object of class B and B itself defines a conversion operator to type A.",Operator Overloading
Exercise 14.50,Show the possible class-type conversion sequences for the initializa- tions of ex1 and ex2. Explain whether the initializations are legal or not. struct LongDouble { LongDouble(double = 0.0); operator double() ; operator float(); { LongDouble ldObj; int exl = ldObj; float ex2 = ldObj;,Operator Overloading
Exercise 14.51,"Show the conversion sequences (if any) needed to call each version of ca1 c and explain why the best viable function is selected. void calc(int); void calc(LongDouble); double dval; calc(dval); // which calc? When we use an overloaded operator with an operand of class type, the can- didate functions include ordinary nonmember versions of that operator, as well as the built-in versions of the operator. Moreover, if the left-hand operand has class type, the overloaded versions of the operator, if any, defined by that class are also included, When we call a named function, member and nonmember functions with the same name do not overload one another. There is no overloading because the syn- tax we use to call a named function distinguishes between member and nonmem- ber functions. When a call is through an object of a class type (or through a refer- ence or pointer to such an object), then only the member functions of that class are considered. When we use an overloaded operator in an expression, there is noth- ing to indicate whether we're using a member or nonmember function. Therefore, both member and nonmember versions must be considered. Note The set of candidate functions for an operator used in an expression can contain both nonmember and member functions. As an example, well define an addition operator for our Sma11Int class: class SmallInt { friend SmallInt operator+(const SmallInt&, const SmallInt&); public: SmallInt(int = 0); //conversion from int private: std::size_t val; };",Operator Overloading
Exercise 14.52,"Which operator+, if any, is selected for each of the addition expres- sions? List the candidate functions, the viable functions, and the type conversions on. the arguments for each viable function: struct LongDouble{ //member operat or+ for illustration purposes; + is usually a nonmember LongDouble operator+(const SmallInt&); //other members as in $ 14.9.2 (p. 587) { LongDouble operator+ (LongDouble&, double); SmallInt si; LongDouble ld; ld = si + ld; ld = ld + si;",Operator Overloading
Exercise 14.53,"Given the definition of Sma11Int on page 588, determine whether. the following addition expression is legal. If so, what addition operator is used? If not, how might you change the code to make it legal?. SmallInt sl; double d = s1 + 3.14;",Operator Overloading
Exercise 15.1,What is a virtual member?,Object-Oriented Programming
Exercise 15.2,How does the protected access specifier differ from private?,Object-Oriented Programming
Exercise 15.3,Define your own versions of the Quote class and the print_total function.,Object-Oriented Programming
Exercise 15.4,"Which of the following declarations, if any, are incorrect? Explain why class Base{...}; a class Derived : public Derived { ... }; b) class Derived : private Base { ... }; (c) class Derived : public Base;",Object-Oriented Programming
Exercise 15.5,Define your own version of the Bulk_quote class.,Object-Oriented Programming
Exercise 15.6,Test your print_tota1 function from the exercises in S 15.2.1 (p. 595) by passing both Quote and Bulk_quote objects o that function.,Object-Oriented Programming
Exercise 15.7,"Define a class that implements a limited discount strategy, which ap-. plies a discount to books purchased up to a given limit. If the number of copies exceeds that limit, the normal price applies to those purchased beyond the limit. 15.2.3 Conversions and Inheritance Understanding conversions between base and derived classes is essen- . WARNING tial to understanding how object-oriented programming works in C++. Ordinarily, we can bind a reference or a pointer only to an object that has the same type as the corresponding reference or pointer (S 2.3.1, p.51, and S 2.3.2, p. 52) or to a type that involves an acceptable const conversion ($ 4.11.2, p. 162). Classes related by inheritance are an important exception: We can bind a pointer or ref- erence to a base-class type to an object of a type derived from that base class. For. example, we can use a Quote & to refer to a Bu1k_quot e object, and we can assign the address of a Bulk quote object to a Quote* The fact that we can bind a reference (or pointer) to a base-class type to a de- rived object has a crucially important implication: When we use a reference (or pointer) to a base-class type, we dont know the actual type of the object to which. the pointer or reference is bound. That object can be an object of the base class or. it can be an object of a derived class.. Like built-in pointers, the smart pointer classes (S 12.1, p. 450) support Note the derived-to-base conversion-we can store a pointer to a derived ob ject in a smart pointer to the base type. Static Type and Dynamic Type When we use types related by inheritance, we often need to distinguish betweer the static type of a variable or other expression and the dynamic type of the object that expression represents. The static type of an expression is always known at. compile time-it is the type with which a variable is declared or that an expression yields. The dynamic type is the type of the object in memory that the variable or expression represents. The dynamic type may not be known until run time.",Object-Oriented Programming
Exercise 15.8,Define static type and dynamic type,Object-Oriented Programming
Exercise 15.9,When is it possible for an expressions static type to differ from its dy- namic type? Give three examples in which the static and dynamic type differ.,Object-Oriented Programming
Exercise 15.10,"Recalling the discussion from  8.1 (p. 311), explain how the program on page 317 that passed an ifstream to the Sales_data read function works. KEY CONCEPT: CONVERSIONS AMONG TYPES RELATED BY INHERITANCE There are three things that are important to understand about conversions among classes related by inheritance: The conversion from derived to base applies only to pointer or reference types. There is no implicit conversion from the base-class type to the derived type. Like any member, the derived-to-base conversion may be inaccessible due to access controls. Well cover accessibility in  15.5 (p. 613). Although the automatic conversion applies only to pointers and references, most classes in an inheritance hierarchy (implicitly or explicitly) define the copy-control members (Chapter 13). As a result, we can often copy, move, or assign an object of derived type to a base-type object. However, copying, moving, or assigning a derived- type object to a base-type object copies, moves, or assigns only the members in the base-class part of the object. need to supply a definition for that function ($ 6.1.2, p. 206). However, we must de fine every virtual function, regardless of whether it is used, because the compiler has no way to determine whether a virtual function is used. Calls to Virtual Functions May Be Resolved at Run Time When a virtual function is called through a reference or pointer, the compiler gen- is the one that corresponds to the dynamic type of the object bound to that pointer or reference. As an example, consider our print tota1 function from S 15.1 (p.593).That function calls net price on its parameter named item, which has type Quote& Because item is a reference, and because net_price is virtual, the version of net pri ce that is called depends at run time on the actual (dynamic) type of the argument bound to it em: Quote base (""0-201-82470-1"",50); print_total(cout, base, 10); // calls Quote::net price Bulk_quote derived(0-201-82470-1,50,5,.19); print_total(cout, derived, 10); // calls Bulk quote::net price In the first call, item is bound to an object of type Quote. As a result, when",Object-Oriented Programming
Exercise 15.11,Add a virtual debug function to your Quote class hierarchy that dis plays the data members of the respective classes.,Object-Oriented Programming
Exercise 15.12,Is it ever useful to declare a member function as both override and final? Why or why not?,Object-Oriented Programming
Exercise 15.13,"Given the following classes, explain each print function: class base public: string name() { return basename; } virtual void print(ostream &os) {os << basename; } private: string basename; { class derived : public base public: void printostream &os) {printos); os <<   << i; } private: int i; }; If there is a problem in this code, how would you fix it?",Object-Oriented Programming
Exercise 15.14,"Given the classes from the previous exercise and the following objects, determine which function is called at run time: base bobj; base *bp1 =&bobj; base &br1 = bobj; derived dobj; base *bp2 = &dobj; base &br2 = dobj; a bobj.print(;b dobj.print; c bp1->name; dbp2->name ebrl.print(; f br2.print(); 15.4Abstract Base Classes Imagine that we want to extend our bookstore classes to support several discount strategies. In addition to a bulk discount, we might offer a discount for purchases up to a certain quantity and then charge the full price thereafter. Or we might offer a discount for purchases above a certain limit but not for purchases up to that limit. Each of these discount strategies is the same in that it requires a quantity and a discount amount. We might support these differing strategies by defining a new class named Disc quote to store the quantity and the discount amount. Classes, such as Bulk_item, that represent a specific discount strategy will inherit from",Object-Oriented Programming
Exercise 15.15,Define your own versions of Disc_quote and Bulk_quote.,Object-Oriented Programming
Exercise 15.16,"Rewrite the class representing a limited discount strategy, which you wrote for the exercises in S 15.2.2 (p. 601), to inherit from Di sc_quote.",Object-Oriented Programming
Exercise 15.17,"Try to define an object of type Di sc_quote and see what errors you get from the compiler. 15.5Access Control and Inheritance Just as each class controls the initialization of its own members (S 15.2.2, p. 598) each class also controls whether its members are accessible to a derived class. protectedMembers As we've seen, a class uses prot ect ed for those members that it is willing to share. with its derived classes but wants to protect from general access. The protected specifier can be thought of as a blend of private and public: . Like private, protected members are inaccessible to users of the class. . Like public, protected members are accessible to members and friends of classes derived from this class. In addition, protected has another important property A derived class member or friend may access the protected members of. the base class only through a derived object. The derived class has no special access to the protected members of base-class objects. To understand this last rule, consider the following example:.",Object-Oriented Programming
Exercise 15.18,"Given the classes from page 612 and page 613, and assuming each object has the type specified in the comments, determine which of these assignments are legal. Explain why those that are illegal aren't allowed: Base *p = &dl// dl has type Pub Derv p =&d2; /7 d2 has type Priv_Derv p =&d3; /7 d3 has type Prot_Derv p = &dd1; // dd1 has type Derived from_Public p =&dd2; /7 dd2 has type Derived_from_Private p =&dd3; /7 dd3 has type Derived_from_Protected",Object-Oriented Programming
Exercise 15.19,"Assume that each of the classes from page 612 and page 613 has a member function of the form: void memfcn(Base &b) {b = *this; } For each class, determine whether this function would be legal.",Object-Oriented Programming
Exercise 15.20,Write code to test your answers to the previous two exercises.,Object-Oriented Programming
Exercise 15.21,"Choose one of the following general abstractions containing a family. of types (or choose one of your own). Organize the types into an inheritance hierarchy:. (a) Graphical file formats (such as gif, tiff, jpeg, bmp) (b) Geometric primitives (such as box, circle, sphere, cone) (c) C++ language types (such as class, function, member function)",Object-Oriented Programming
Exercise 15.22,"For the class you chose in the previous exercise, identify some of the. likely virtual functions as well as public and protected members.",Object-Oriented Programming
Exercise 15.23,"Assuming class D1 on page 620 had intended to override its inherited f cn function, how would you fix that class? Assuming you fixed the class so that f cn . matched the definition in Base, how would the calls in that section be resolved?",Object-Oriented Programming
Exercise 15.24,"What kinds of classes need a virtual destructor? What operations must a virtual destructor perform? 15.7.2Synthesized Copy Control and Inheritance The synthesized copy-control members in a base or a derived class execute like any other synthesized constructor, assignment operator, or destructor: They mem- berwise initialize, assign, or destroy the members of the class itself. In addition these synthesized members initialize, assign, or destroy the direct base part of an object by using the corresponding operation from the base class. For example,. . The synthesized Bulk quote default constructor runs the Disc Quote de fault constructor, which in turn runs the Quote default constructor. . The Quote default constructor default initializes the bookNo member to the empty string and uses the in-class initializer to initialize pri ce to zero.. . When the Quote constructor finishes, the Disc Quote constructor contin- ues, which uses the in-class initializers to initialize qty and di scount. . When the Disc quote constructor finishes, the Bulk quote constructor continues but has no other work to do. Similarly, the synthesized Bulk_quote copy constructor uses the (synthesized) Disc_quote copy constructor, which uses the (synthesized) Quote copy con- structor. The Quote copy constructor copies the bookNo and price members;. and the Disc_Quote copy constructor copies the qty and discount members. It is worth noting that it doesn't matter whether the base-class member is it self synthesized (as is the case in our Quote hierarchy) or has a an user-provided definition. All that matters is that the corresponding member is accessible ($ 15.5, p. 611) and that it is not a deleted function. Each of our Quote classes use the synthesized destructor. The derived classes do so implicitly, whereas the Quote class does so explicitly by defining its (virtual) destructor as = default. The synthesized destructor is (as usual) empty and its implicit destruction part destroys the members of the class (S 13.1.3, p. 501). In addition to destroying its own members, the destruction phase of a destructor in a derived class also destroys its direct base. That destructor in turn invokes the destructor for its own direct base, if any. And, so on up to the root of the hierarchy.",Object-Oriented Programming
Exercise 15.25,"Why did we define a default constructor for Disc_quote? What ef-. fect, if any, would removing that constructor have on the behavior of Bulk_quote? 15.7.3Derived-Class Copy-Control Members As we saw in S 15.2.2 (p.598), the initialization phase of a derived-class constructor initializes the base-class part(s) of a derived object as well as initializing its own members. As a result, the copy and move constructors for a derived class must. copy/move the members of its base part as well as the members in the derived Similarly, a derived-class assignment operator must assign the members in the base part of the derived object. Unlike the constructors and assignment operators, the destructor is responsible. only for destroying the resources allocated by the derived class. Recall that the members of an object are implicitly destroyed ($ 13.1.3, p. 502). Similarly, the base- class part of a derived object is destroyed automatically.",Object-Oriented Programming
Exercise 15.26,"Define the Quote and Bulk quote copy-control members to do the same job as the synthesized versions. Give them and the other constructors print state-. ments that identify which function is running. Write programs using these classes and predict what objects will be created and destroyed. Compare your predictions with the output and continue experimenting until your predictions are reliably correct. 15.7.4Inherited Constructors Under the new standard, a derived class can reuse the constructors defined by its direct base class. Although, as well see, such constructors are not inherited in the normal sense of that term, it is nonetheless common to refer to such constructors. as ""inherited."" For the same reasons that a class may initialize only its direct base class, a class may inherit constructors only from its direct base. A class cannot inherit the default, copy, and move constructors. If the derived class does not directly define these constructors, the compiler synthesizes them as usual. A derived class inherits its base-class constructors by providing a using dec- laration that names its (direct) base class. As an example, we can redefine our. Bu1k_quote class (S 15.4, p. 610) to inherit its constructors from Di sc_quote: class Bulk_quote : public Disc_quote { public: using Disc_quote::Disc_quote; // inherit Disc_quotes constructors double net_price(std::size_t) const; 1 { Ordinarily, a using declaration only makes a name visible in the current scope. When applied to a constructor, a using declaration causes the compiler to gen- erate code. The compiler generates a derived constructor corresponding to each constructor in the base. That is, for each constructor in the base class, the compiler generates a constructor in the derived class that has the same parameter list.",Object-Oriented Programming
Exercise 15.27,Redefine your Bulk_quot e class to inherit its constructors,Object-Oriented Programming
Exercise 15.28,Define a vector to hold Quote objects but put Bulk_quote objects into that vector. Compute the total net_pri ce of all the elements in the vector.,Object-Oriented Programming
Exercise 15.29,"Repeat your program, but this time store shared_ptrs to objects of type Quote. Explain any discrepancy in the sum generated by the this version and the previous program. If there is no discrepancy, explain why there isn't one 15.8.1 Writing a Basket Class One of the ironies of object-oriented programming in C++ is that we cannot use ob- jects directly to support it. Instead, we must use pointers and references. Because. pointers impose complexity on our programs, we often define auxiliary classes to. help manage that complexity. Well start by defining a class to represent a basket: class Basket { public: I /Baske t uses synthesized default constructor and copy-control members. void add_item(const std::shared ptr<Quote> &sale). {items.insert(sale); } I / prints the total price for each book and the overall total for all items in the basket double total_receipt(std::ostream&) const; private: // function to compare shared_ptrs needed by the mul tiset member. static bool compare(const std::shared ptr<Quote> &lhs, const std::shared_ptr<Quote> &rhs) {return lhs->isbn() < rhs->isbn();} / /mul ti set to hold multiple quotes, ordered by the compare member std::multiset<std::shared_ptr<Quote>, decltype (compare) *> items{compare}; } ; Our class uses a multiset (S 11.2.1, p. 423) to hold the transactions, so that we can store multiple transactions for the same book, and so that all the transactions. for a given book will be kept together (S 11.2.2, p. 424). The elements in our mu1tiset are shared_ptrs and there is no less-than op erator for shared ptr. As a result, we must provide our own comparison oper- ation to order the elements (S 11.2.2, p. 425). Here, we define a private static member, named compare, that compares the isbns of the objects to which the shared ptrs point. We initialize our multiset to use this comparison function through an in-class initializer ($ 7.3.1, p. 274):",Object-Oriented Programming
Exercise 15.30,"Write your own version of the Basket class and use it to compute prices for the same transactions as you used in the previous exercises. 15.9Text Oueries Revisited As a final example of inheritance, well extend our text-query application from S 12.3 (p. 484). The classes we wrote in that section let us look for occurrences of a",Object-Oriented Programming
Exercise 15.31,"Given that s1, s2, s3, and s4 are all strings, determine what objects. are created in the following expressions: aQuerys1Querys2&~Querys3; bQuerysl Querys2&~Querys3; cQuerys1&Querys2|Querys3&Querys4; 15.9.2  The Query base and Query Classes We'll start our implementation by defining the Query base class: J Iabstract class acts as a base class for concrete query types; all members are pri vate class Query_base friend class Query; protected: using line no = TextQuery::line no; // used in the eval functions virtual ~Query_base() = default; private: // eva1 returns the QueryResu1 t that matches this Query. virtual QueryResult eval(const TextQuery&) const = 0; // repis a string representation of the query. virtual std::string rep() const = 0; 1{ Both eval and rep are pure virtual functions, which makes Query base an ab stract base class (S 15.4, p. 610). Because we dont intend users, or the derived classes, to use Query_base directly, Query_base has no public members. All use of Query base will be through Query objects. We grant friendship to the. Query class, because members of Query will call the virtuals in Query base. The protected member, line_no, will be used inside the eval functions.. Similarly, the destructor is protected because it is used (implicitly) by the de-. structors in the derived classes",Object-Oriented Programming
Exercise 15.32,"What happens when an object of type Query is copied, moved, as- signed, and destroyed?",Object-Oriented Programming
Exercise 15.33,What about objects of type Query_base?,Object-Oriented Programming
Exercise 15.34,For the expression built in Figure 15.3 (p. 638) (a) List the constructors executed in processing that expression. (b) List the calls to rep that are made from cout << q. (c) List the calls to eval made from q. eval ().,Object-Oriented Programming
Exercise 15.35,"Implement the Query and Query_base classes, including a defini- tion of rep but omitting the definition of eval.",Object-Oriented Programming
Exercise 15.36,Put print statements in the constructors and rep members and run. your code to check your answers to (a) and (b) from the first exercise.,Object-Oriented Programming
Exercise 15.37,What changes would your classes need if the derived classes had members of type shared_ptr<Query_base> rather than of type Query?,Object-Oriented Programming
Exercise 15.38,"Are the following declarations legal? If not, why not? If so, explain what the declarations mean. BinaryQuery a = Query(""fiery"") & Query(""bird""); OrQuery c = Query(""fiery"") & Query(""bird""); 15.9.4The eva1 Functions The eva1 functions are the heart of our query system. Each of these functions calls eva1 on its operand(s) and then applies its own logic: The OrQuery eva1 oper- ation returns the union of the results of its two operands; AndQuery returns the intersection. The NotQuery is more complicated: It must return the line numbers that are not in its operand's set. To support the processing in the eva1 functions, we need to use the version of QueryResu1t that defines the members we added in the exercises to $ 12.3.2 (p. 490). Well assume that QueryResu1t has begin and end members that will let us iterate through the set of line numbers that the QueryResult holds. We'll also assume that QueryResult has a member named get file that returns a. shared_pt r to the underlying file on which the query was executed. Our Query classes use members defined for QueryResu1t in the exer- WARNING cises to $ 12.3.2 (p. 490) OrQuery::eval An OrQuery represents the union of the results for its two operands, which we obtain by calling eva1 on each of its operands. Because these operands are Query objects, calling eval is a call to Query: : eval, which in turn makes a virtual call to eva1 on the underlying Query_base object. Each of these calls yields a QueryResu1t representing the line numbers in which its operand appears. We'll combine those line numbers into a new set:.",Object-Oriented Programming
Exercise 15.39,Implement the Query and Query_base classes. Test your application. by evaluating and printing a query such as the one in Figure 15.3 (p. 638),Object-Oriented Programming
Exercise 15.40,In the OrQuery eva1 function what would happen if its rhs member returned an empty set? What if its 1hs member did so? What if both rhs and 1hs. returned empty sets?,Object-Oriented Programming
Exercise 15.41,Reimplement your classes to use built-in pointers to Query_base rather than shared_ptrs. Remember that your classes will no longer be able to use the synthesized copy-control members.,Object-Oriented Programming
Exercise 15.42,"Design and implement one of the following enhancements: (a) Print words only once per sentence rather than once per line. (b) Introduce a history system in which the user can refer to a previous query by number, possibly adding to it or combining it with another. (c) Allow the user to limit the results so that only matches in a given range of lines are displayed.",Object-Oriented Programming
Exercise 16.1,Define instantiation.,Templates
Exercise 16.2,Write and test your own versions of the compare functions.,Templates
Exercise 16.3,Call your compare function on two Sales_data objects to see how your compiler handles errors during instantiation.,Templates
Exercise 16.4,"Write a template that acts like the library f ind algorithm. The func- tion will need two template type parameters, one to represent the function's iterator parameters and the other for the type of the value. Use your function to find a given value in a vector<int> and in a list<string>.",Templates
Exercise 16.5,Write a template version of the print function from $ 6.2.4 (p. 217) that takes a reference to an array and can handle arrays of any size and any element type.,Templates
Exercise 16.6,How do you think the library begin and end functions that take an array argument work? Define your own versions of these functions.,Templates
Exercise 16.7,Write a constexpr template that returns the size of a given array,Templates
Exercise 16.8,"In the Key Concept box on page 108, we noted that as a matter of habit C++ programmers prefer using ! = to using <. Explain the rationale for this habit. 16.1.2Class Templates A class template is a blueprint for generating classes. Class templates differ from function templates in that the compiler cannot deduce the template parameter type(s) for a class template. Instead, as we've seen many times, to use a class template we must supply additional information inside angle brackets following",Templates
Exercise 16.9,What is a function template? What is a class template?,Templates
Exercise 16.10,What happens when a class template is instantiated?,Templates
Exercise 16.11,"The following definition of Li st is incorrect. How would you fix it? template <typename elemType> class ListItem; template <typename elemType> class List { public: List<elemType>() ; List<elemType> (const List<elemType> &); List<elemType>& operator= (const List<elemType> &) ; ~List(); void insert (ListItem +ptr, elemType value) ; private: ListItem +front, *end; {",Templates
Exercise 16.12,Write your own version of the B1ob and B1obPtr templates. includ. ing the various const members that were not shown in the text.,Templates
Exercise 16.13,Explain which kind of friendship you chose for the equality and rela. tional operators for BlobPtr.,Templates
Exercise 16.14,Write a Screen class template that uses nontype parameters to define the height and width of the Screen..,Templates
Exercise 16.15,"Implement input and output operators for your Screen template. Which, if any, friends are necessary in class Screen to make the input and output. operators work? Explain why each friend declaration, if any, was needed..",Templates
Exercise 16.16,"Rewrite the StrVec class ($ 13.5, p. 526) as a template named Vec 16.1.3 Template Parameters Like the names of function parameters, a template parameter name has no intrinsic meaning. We ordinarily name type parameters T, but we can use any name: template <typename Foo> Foo calc(const Foo& a, const Foo& b). Foo tmp = a; / / tmp has the same type as the parameters and return type //... return tmp;/ /return type and parameters have the same type Template Parameters and Scope Template parameters follow normal scoping rules. The name of a template pa- rameter can be used after it has been declared and until the end of the template declaration or definition. As with any other name, a template parameter hides any",Templates
Exercise 16.17,"What, if any, are the differences between a type parameter that is de- clared as a typename and one that is declared as a class? When must typename be used?",Templates
Exercise 16.18,"Explain each of the following function template declarations and iden- tify whether any are illegal. Correct each error that you find.. (a) template <typename T, U, typename V> void f1(T, U, V); (b) template <typename T> T f2(int &T); (c) inline template <typename T> T foo(T, unsigned int+); (d) template <typename T> f4 (T, T); (e) typedef char Ctype; template <typename Ctype> Ctype f5(Ctype a);",Templates
Exercise 16.19,Write a function that takes a reference to a container and prints the elements in that container. Use the container's size_type and size members to control the loop that prints the elements.,Templates
Exercise 16.20,"Rewrite the function from the previous exercise to use iterators re- turned from begin and end to control the loop, 16.1.4Member Templates A class-either an ordinary class or a class templatemay have a member func- tion that is itself a template. Such members are referred to as member templates. Member templates may not be virtual. Member Templates of Ordianary (Nontemplate) Classes As an example of an ordinary class that has a member template, well define a class that is similar to the default deleter type used by unique ptr (S 12.1.5, p. 471). Like the default deleter, our class will have an overloaded function-call operator (S 14.8, p. 571) that will take a pointer and execute de1ete on the given pointer. Unlike the default deleter, our class will also print a message whenever the deleter is executed. Because we want to use our deleter with any type, well make the call operator a template: / /function-object class that calls de1 ete on a given pointer class DebugDelete { public: DebugDelete(std::ostream &s = std::cerr): os(s) { } 1 / as with any function template, the type of T is deduced by the compiler template <typename T> void operator() (T *p) const {os << ""deleting unique_ptr"" << std::endl; delete p; } private: std::ostream &os; } ;",Templates
Exercise 16.21,Write your own version of DebugDe1ete..,Templates
Exercise 16.22,"Revise your TextQuery programs from $ 12.3 (p.484) so that the shared_ptr members use a DebugDelete as their deleter ($ 12.1.4, p. 468).",Templates
Exercise 16.23,"Predict when the call operator will be executed in your main query program. If your expectations and what happens differ, be sure you understand why",Templates
Exercise 16.24,"Add a constructor that takes two iterators to your B1ob template. 16.1.5 Controlling Instantiations The fact that instantiations are generated when a template is used ($ 16.1.1, p. 656) means that the same instantiation may appear in multiple object files. When two or more separately compiled source files use the same template with the same template arguments, there is an instantiation of that template in each of those files In large systems, the overhead of instantiating the same template in multiple files can become significant. Under the new standard, we can avoid this overhead C++ through an explicit instantiation. An explicit instantiation has the form. extern template declaration; //instantiation declaration template declaration; //instantiation definition where declaration is a class or function declaration in which all the template param eters are replaced by the template arguments. For example, instantion declaration and definition extern template class Blob<string>; declaration template int compare(const int&, const int&); // definition When the compiler sees an ext ern template declaration, it will not generate code for that instantiation in that file. Declaring an instantiation as extern is a promise that there will be a nonextern use of that instantiation elsewhere in the program. There may be several ext ern declarations for a given instantiation but there must be exactly one definition for that instantiation. Because the compiler automatically instantiates a template when we use it, the ext ern declaration must appear before any code that uses that instantiation:. // Application.cc I/ these template types must be instantiated elsewhere in the program extern template class Blob<string>; extern template int compare(const int&, const int&); Blob<string> sal, sa2; // instantiation will appear elsewhere // Blob<int>and its initializer_list constructor instantiated in this file Blob<int>a1 ={0,1,2,3,4,5,6,7,8,9}; Blob<int> a2 (a1) ;  // copy constructor instantiated in this file int i = compare (a1 [0], a2 [0]) ; // instantiation will appear elsewhere",Templates
Exercise 16.25,Explain the meaning of these declarations: extern template class vector<string>; template class vector<Sales_data>;,Templates
Exercise 16.26,"Assuming NoDe f au1 t is a class that does not have a default construc- tor, can we explicitly instantiate vector<NoDe f ault >? If not, why not?",Templates
Exercise 16.27,"For each labeled statement explain what, if any, instantiations happen If a template is instantiated, explain why; if not, explain why not. template <typename T> class Stack {}; void f1(Stack<char>); //a class Exercise { Stack<double> &rsd; //b) Stack<int> si; //c) }; int main(){ Stack<char> *sc; //(d) f1(*Sc); //(e) int iObj = sizeof(Stack< string >); // f) The difference in how the deleter is handled is incidental to the functionality may have important performance impacts. Binding the Deleter at Run Time Although we don't know how the library types are implemented, we can infer that. shared ptr must access its deleter indirectly. That is the deleter must be stored as a pointer or as a class (such as funct ion ($ 14.8.3, p. 577)) that encapsulates a pointer. We can be certain that shared ptr does not hold the deleter as a direct mem ber, because the type of the deleter isnt known until run time. Indeed, we can change the type of the deleter in a given shared ptr during that shared ptr's. lifetime. We can construct a shared_ptr using a deleter of one type, and subse- quently use reset to give that same shared_ptr a different type of deleter. In general, we cannot have a member whose type changes at run time. Hence, the deleter must be stored indirectly.. To think about how the deleter must work, let's assume that shared ptr. stores the pointer it manages in a member named p, and that the deleter is ac-. cessed through a member named de1. The shared_ptr destructor must include a statement such as I/value of de1 known only at run time; call through a pointer del ? del (p) : delete p; // del (p) requires run-time jump to dels location",Templates
Exercise 16.28,Write your own versions of shared_ptr and unique_ptr.,Templates
Exercise 16.29,Revise your B1ob class to use your version of shared_ptr rather than the library version.,Templates
Exercise 16.30,"Rerun some of your programs to verify your shared_ptr and re- vised B1ob classes. (Note: Implementing the weak_ptr type is beyond the scope of this Primer, so you will not be able to use the B1obPt r class with your revised B1ob.)",Templates
Exercise 16.31,"Explain how the compiler might inline the call to the deleter if we used DebugDelete with unique_ptr.. 16.2 Template Argument Deduction We've seen that, by default, the compiler uses the arguments in a call to determine the template parameters for a function template. The process of determining the template arguments from the function arguments is known as template argument deduction. During template argument deduction, the compiler uses types of the arguments in the call to find the template arguments that generate a version of the function that best matches the given call..",Templates
Exercise 16.32,What happens during template argument deduction?,Templates
Exercise 16.33,Name two type conversions allowed on function arguments involved in template argument deduction.,Templates
Exercise 16.34,"Given only the following code, explain whether each of these calls is legal. If so, what is the type of T? If not, why not? template <class T> int compare(const T&, const T&); a)compare(""hi"",""world"");b) compare(""bye"",""dad"");",Templates
Exercise 16.35,"Which, if any, of the following calls are errors? If the call is legal, what is the type of T? If the call is not legal, what is the problem? template <typename T> T calc(T, int) ; template <typename T> T fcn(T, T); double d; float f; char c; acalcc,c;bcalcdf; cfcncc; dfcn(df;",Templates
Exercise 16.36,"What happens in the following calls template <typename T> f1(T, T); template <typename T1, typename T2) f2(T1, T2); inti=0j=42*pl =&i*p2=&j; const int *cpl = &i, *cp2 = &j; af1plp2; bf2plp2; c f1cplcp2; d f2cpl cp2;ef1p1cp1; (e f2(pl, cp1; 16.2.2 Function-Template Explicit Arguments In some situations, it is not possible for the compiler to deduce the types of the template arguments. In others, we want to allow the user to control the template",Templates
Exercise 16.37,"The library max function has two function parameters and returns the larger of its arguments. This function has one template type parameter. Could you call max passing it an int and a double? If so, how? If not, why not?.",Templates
Exercise 16.38,"When we call make_shared ($ 12.1.1, p. 451), we have to provide an explicit template argument. Explain why that argument is needed and how it is used.",Templates
Exercise 16.39,"Use an explicit template argument to make it sensible to pass two string literals to the original version of compare from $ 16.1.1 (p. 652) 16.2.3 Trailing Return Types and Type Transformation. Using an explicit template argument to represent a template function's return type works well when we want to let the user determine the return type. In other cases. requiring an explicit template argument imposes a burden on the user with no. compensating advantage. For example, we might want to write a function that takes a pair of iterators denoting a sequence and returns a reference to an element. in the sequence: template <typename It> ??? &fcn(It beg, It end) //process the range We dont know the exact type we want to return, but we do know that we want that type to be a reference to the element type of the sequence we're processing vector<int> vi ={1,2,3,4,5}; Blob<string> ca ={""hi"",""bye""}; auto &i = fcn(vi.begin), vi.end()); // fcn should return int&. auto &s = fcn(ca.begin(), ca.end()); // fcn should return string&",Templates
Exercise 16.40,"Is the following function legal? If not, why not? If it is legal, what, if any, are the restrictions on the argument type(s) that can be passed, and what is the return type? template <typename It> auto fcn3 (It beg, It end) -> decltype(*beg + 0) /process the range return +beg;//return a copy of an element from the range",Templates
Exercise 16.41,"Write a version of sum with a return type that is guaranteed to be large enough to hold the result of the addition. 16.2.4Function Pointers and Argument Deduction. When we initialize or assign a function pointer (S 6.7, p. 247) from a function tem- plate, the compiler uses the type of the pointer to deduce the template argument(s), As an example, assume we have a function pointer that points to a function returning an int that takes two parameters, each of which is a reference to a const int. We can use that pointer to point to an instantiation of compare: template <typename T> int compare(const T&, const T&); // pf1points to the instantiation int compare(const int&, const int&) int (*pf1) (const int&, const int&) = compare; The type of the parameters in pf 1 determines the type of the template argument for T. The template argument for T is int. The pointer pf1 points to the instan- tiation of compare with T bound to int. It is an error if the template arguments cannot be determined from the function pointer type: I /overloaded versions of func; each takes a different function pointer type void func(int(*) (const string&, const string&)); void func(int(*) (const int&, const int&)); func (compare) ; // error: which instantiation of compare? The problem is that by looking at the type of func's parameter, it is not possible to determine a unique type for the template argument. The call to func could instan- tiate the version of compare that takes ints or the version that takes strings. Because it is not possible to identify a unique instantiation for the argument to func, this call won't compile. We can disambiguate the call to func by using explicit template arguments: I /ok: explicitly specify which version of compare to instantiate func (compare<int>) ; // passing compare (const int&, const int&) This expression calls the version of func that takes a function pointer with two const int& parameters.",Templates
Exercise 16.42,Determine the type of T and of va1 in each of the following calls: template <typename T> void g(T&& val); int i = 0; const int ci = i; a gi; b gci; c gi * ci;,Templates
Exercise 16.43,"Using the function defined in the previous exercise, what would the template parameter of g be if we called g(i = ci) ?",Templates
Exercise 16.44,"Using the same three calls as in the first exercise, determine the types for T if gs function parameter is declared as T (not T& &). What if gs function parame- ter is const T&?",Templates
Exercise 16.45,"Given the following template, explain what happens if we call g on a literal value such as 42. What if we call g on a variable of type int? template <typename T> void g(T&& val) {vector<T> v; } 16.2.6Understanding std::move The library move function (S 13.6.1, p. 533) is a good illustration of a template that uses rvalue references. Fortunately, we can use move without understanding the template mechanisms that it uses. However, looking at how move works can help cement our general understanding, and use, of templates.. In S 13.6.2 (p. 534) we noted that although we cannot directly bind an rvalue reference to an lvalue, we can use move to obtain an rvalue reference bound to an Ivalue. Because move can take arguments of essentially any type, it should not be surprising that move is a function template. How std::move Is Defined The standard defines move as follows:. / /for the use of typename in the return type and the cast see $ 16.1.3 (p. 670) // remove_reference is covered in 16.2.3 (p. 684) template <typename T> typename remove_reference<T>::type&& move (T&& t) // static_cast covered in $4.11.3 (p.163) return static_cast<typename remove_reference<T>::type&&>(t); This code is short but subtle. First, move's function parameter, T&&, is an rvalue reference to a template parameter type. Through reference collapsing, this param- or an rvalue to move:. string sl(""hi!""),s2; s2 = std::move(string(""bye!""));// ok:moving froman roalue s2 = std: :move (s1) ; / / ok: but after the assigment s1 has indeterminate value",Templates
Exercise 16.46,"Explain this loop from StrVec : : rea11ocate in S 13.5 (p. 530): for size_ti = 0 i != size(); ++i) alloc.construct (dest++, std: :move (elem++)) ; 16.2.7 Forwarding Some functions need to forward one or more of their arguments with their types unchanged to another, forwarded-to, function. In such cases, we need to preserve. everything about the forwarded arguments, including whether or not the argu- ment type is const, and whether the argument is an lvalue or an rvalue. As an example, well write a function that takes a callable expression and two additional arguments. Our function will call the given callable with the other two arguments in reverse order. The following is a first cut at our flip function:. I 1template that takes a callable and two parameters and calls the given callable with the parameters flipped I /f1ip1 is an incomplete implementation: top-level const and references are lost template <typename F, typename T1, typename T2> void flipl(F f, T1 t1, T2 t2) { f(t2,t1); This template works fine until we want to use it to call a function that has a refer-. ence parameter: void f(int vl, int &v2) //note v2 is a reference cout <vl << << ++v2 < endl; { Here f changes the value of the argument bound to v2. However, if we call f through f1ip1, the changes made by f do not affect the original argument:. f(42i; // f changes its argument i flip1(f, j, 42);// f called through f1ip1 leaves j unchanged The problem is that j is passed to the t1 parameter in f 1ip1. That parameter has is a plain, nonreference type, int, not an int&. That is, the instantiation of this call to f1ip1 is",Templates
Exercise 16.47,"Write your own version of the flip function and test it by calling func- tions that have lvalue and rvalue reference parameters.d Function matching (S 6.4, p. 233) is affected by the presence of function tem- plates in the following ways:. . The candidate functions for a call include any function-template instantiation for which template argument deduction (S 16.2, p. 678) succeeds. The candidate function templates are always viable, because template argu- ment deduction will have eliminated any templates that are not viable.. As usual, the viable functions (template and nontemplate) are ranked by the conversions, if any, needed to make the call. Of course, the conversions used to call a function template are quite limited ($ 16.2.1, p. 679). Also as usual, if exactly one function provides a better match than any of the. others, that function is selected. However, if there are several functions that provide an equally good match, then:. - If there is only one nontemplate function in the set of equally good matches, the nontemplate function is called. If there are no nontemplate functions in the set, but there are multiple. function templates, and one of these templates is more specialized thar any of the others, the more specialized function template is called. Otherwise, the call is ambiguous. Correctly defining a set of overloaded function templates requires a good understanding of the relationship among types and of the re- WARNING stricted conversions applied to arguments in template functions. Writing Overloaded Templates As an example, we'll build a set of functions that might be useful during debug. ging. Well name our debugging functions debug_rep, each of which will return. a string representation of a given object. Well start by writing the most general version of this function as a template that takes a reference to a const object: I/print any type we don't otherwise handle. template <typename T> string debug rep(const T &t) ostringstream ret; // see8.3(p.321) ret << t; //uses Ts output operator to print a representation of t return ret.str();// return a copy ofthe string to which ret is bound",Templates
Exercise 16.48,Write your own versions of the debug_rep functions.,Templates
Exercise 16.49,"Explain what happens in each of the following calls: template <typename T> void f(T); template <typename T> void f(const T*); template <typename T> void g(T) ; template <typename T> void g(T*); int i =42, *p = &i; const int ci = 0, *p2 = &ci; g(42); d6 g(ci); gp2); f (42) ; fp); f(ci); fp2;",Templates
Exercise 16.50,"Define the functions from the previous exercise so that they print an identifying message. Run the code from that exercise. If the calls behave differently from what you expected, make sure you understand why. 16.4Variadic Templates A variadic template is a template function or class that can take a varying number of parameters. The varying parameters are known as a parameter pack. There are two kinds of parameter packs: A template parameter pack represents zero or",Templates
Exercise 16.51,Determine what sizeof... (Args) and sizeof... (rest) return for each call to foo in this section.,Templates
Exercise 16.52,"Write a program to check your answer to the previous question 16.4.1 Writing a Variadic Function Template function that can take a varying number of arguments. However, the arguments must have the same type (or types that are convertible to a common type). Vari- adic functions are used when we know neither the number nor the types of the arguments we want to process. As an example, well define a function like our earlier error_msg function, only this time well allow the argument types to vary as well. Well start by defining a variadic function named print that will print the contents of a given list of arguments on a given stream. Variadic functions are often recursive (S 6.3.2, p. 227). The first call processes the first argument in the pack and calls itself on the remaining arguments. Our pr int function will execute this wayeach call will print its second argument on the stream denoted by its first argument. To stop the recursion, well also need to define a nonvariadic print function that will take a stream and an object: function to end the recursion and print the last element / /this function must be declared before the variadic version of print is defined template<typename T> ostream &print (ostream &os, const T &t) return os << t; // no separator after the last element in the pack } / /this version of print will be called for all but the last element in the pack template <typename T, typename... Args> ostream &print (ostream &os, const T &t, const Args&... rest) os<<t<<"" //print the first argument return print (os, rest...) ; // recursive call; print the other arguments The first version of print stops the recursion and prints the last argument in the initial call to print. The second, variadic, version prints the argument bound to t and calls itself to print the remaining values in the function parameter pack. The key part is the call to print inside the variadic function: return print (os, rest...); // recursive call; print the other arguments The variadic version of our print function takes three parameters: an ost ream& a const T&, and a parameter pack. Yet this call passes only two arguments. What happens is that the first argument in rest gets bound to t. The remaining ar guments in rest form the parameter pack for the next call to print. Thus, on",Templates
Exercise 16.53,"Write your own version of the print functions and test them by print ing one, two, and five arguments, each of which should have different types..",Templates
Exercise 16.54,What happens if we call print on a type that doesnt have an << operator?,Templates
Exercise 16.55,"Explain how the variadic version of print would execute if we de clared the nonvariadic version of print after the definition of the variadic version. 16.4.2PackExpansion Aside from taking its size, the only other thing we can do with a parameter pack is to expand it. When we expand a pack, we also provide a pattern to be used on",Templates
Exercise 16.56,Write and test a variadic version of errorMsg,Templates
Exercise 16.57,"Compare your variadic version of errorMsg to the error_msg func tion in $ 6.2.6 (p. 220). What are the advantages and disadvantages of each approach? 16.4.3 Forwarding Parameter Packs Under the new standard, we can use variadic templates together with forward to write functions that pass their arguments unchanged to some other function. C+4 To illustrate such functions, well add an emp1ace back member to our StrVec class (S 13.5, p. 526). The emplace back member of the library containers is a variadic member template ($ 16.1.4, p. 673) that uses its arguments to construct an element directly in space managed by the container.. Our version of emplace back for StrVec will also have to be variadic, be- cause st ring has a number of constructors that differ in terms of their parameters..",Templates
Exercise 16.58,Write the emplace_back function for your StrVec class and for the Vec class that you wrote for the exercises in  16.1.2 (p. 668),Templates
Exercise 16.59,"Assuming s is a string,explain svec.emplace_back (s).",Templates
Exercise 16.60,"Explain how make_shared (S12.1.1, p. 451) works",Templates
Exercise 16.61,"Define your own version of make_shared. 16.5 Template Specializations It is not always possible to write a single template that is best suited for every possible template argument with which the template might be instantiated. In some cases, the general template definition is simply wrong for a type: The general definition might not compile or might do the wrong thing. At other times, we may be able to take advantage of some specific knowledge to write more efficient code than would be instantiated from the template. When we can't (or don't want to) use the template version, we can define a specialized version of the class or function template. Our compare function is a good example of a function template for which the general definition is not appropriate for a particular type, namely, character pointers.Wed like compare to compare character pointers by calling strcmp rather than by comparing the pointer values. Indeed, we have already overloaded the compare function to handle character string literals ($ 16.1.1, p. 654):",Templates
Exercise 16.62,Define your own version of hash<Sales_data> and define an unordered_ multiset of Sales_data objects. Put several transactions into the con- tainer and print its contents.,Templates
Exercise 16.63,"Define a function template to count the number of occurrences of a given value in a vector. Test your program by passing it a vector of doubles, a vector of ints, and a vector of strings.",Templates
Exercise 16.64,Write a specialized version of the template from the previous exercise to handle vector<const char+> and a program that uses this specialization.,Templates
Exercise 16.65,In  16.3 (p. 698) we defined overloaded two versions of debug_rep one had a const char+ and the other a char + parameter. Rewrite these functions as specializations.,Templates
Exercise 16.66,What are the advantages and disadvantages of overloading these debug_rep functions as compared to defining specializations?,Templates
Exercise 16.67,"Would defining these specializations affect function matching for debug_rep? If so, how? If not, why not?.",Templates
Exercise 17.1,"Define a tup1e that holds three int values and initialize the members to 10, 20, and 30.",Specialised Library Facilities
Exercise 17.2,"Define a tuple that holds a string, a vector<string>, and a pair<string, int>.",Specialised Library Facilities
Exercise 17.3,Rewrite the TextQuery programs from $ 12.3 (p. 484) to use a tup1e instead of the QueryResu1t class. Explain which design you think is better and why,Specialised Library Facilities
Exercise 17.4,Write and test your own version of the f indBook function.,Specialised Library Facilities
Exercise 17.5,Rewrite findBook to return a pair that holds an index and a pair of iterators.,Specialised Library Facilities
Exercise 17.6,Rewrite findBook so that it does not use tuple or pair.,Specialised Library Facilities
Exercise 17.7,Explain which version of f indBook you prefer and why..,Specialised Library Facilities
Exercise 17.8,"What would happen if we passed Sales_data () as the third param- eter to accumul ate in the last code example in this section?. 17.2 The bitset Type In $ 4.8 (p. 152) we covered the built-in operators that treat an integral operand as a collection of bits. The standard library defines the bi tset class to make it easier. to use bit operations and possible to deal with collections of bits that are larger than the longest integral type. The bitset class is defined in the bit set header. 17.2.1 Defining and Initializing bitsets Table 17.2 (overleaf) lists the constructors for bit set. The bitset class is a class template that, like the array class, has a fixed size (S 9.2.4, p. 336). When we define a bitset, we say how many bits the bitset will contain: bitset<32 > bitvec (1U); // 32 bits; low-order bit is 1, remaining bits are 0 The size must be a constant expression (S 2.4.4, p. 65). This statement defines bitvec as a bitset that holds 32 bits. Just as with the elements of a vector, the bits in a bitset are not named. Instead, we refer to them positionally. The bits are numbered starting at 0. Thus, bitvec has bits numbered 0 through 31. The. bits starting at 0 are referred to as the low-order bits, and those ending at 31 are. referred to as high-order bits. Initializing a bitset from an unsigned Value. When we use an integral value as an initializer for a bitset, that value is con- verted to unsigned long long and is treated as a bit pattern. The bits in the bitset are a copy of that pattern. If the size of the bitset is greater than the number of bits in an unsigned 1ong 1ong, then the remaining high-order bits",Specialised Library Facilities
Exercise 17.9,Explain the bit pattern each of the following bi t set objects contains: (a) bitset<64> bitvec(32); (b) bitset<32> bv(1010101); (c) string bstr; cin >> bstr; bitset<8>bv(bstr); 17.2.2 Operations on bitsets The bi t set operations (Table 17.3 (overleaf)) define various ways to test or set one or more bits. The bi t set class also supports the bitwise operators that we covered in S 4.8 (p. 152). The operators have the same meaning when applied to bitset objects as the built-in operators have when applied to unsigned operands.,Specialised Library Facilities
Exercise 17.10,"Using the sequence 1, 2, 3, 5, 8, 13, 21, initialize a bit set that has a 1 bit in each position corresponding to a number in this sequence. Default initialize another bi t set and write a small program to turn on each of the appropriate bits.",Specialised Library Facilities
Exercise 17.11,"Define a data structure that contains an integral object to track re- sponses to a true/false quiz containing 10 questions. What changes, if any, would you need to make in your data structure if the quiz had 100 questions?",Specialised Library Facilities
Exercise 17.12,"Using the data structure from the previous question, write a function that takes a question number and a value to indicate a true/false answer and updates the quiz results accordingly.",Specialised Library Facilities
Exercise 17.13,"Write an integral object that contains the correct answers for the true/false quiz. Use it to generate grades on the quiz for the data structure from the. previous two exercises. 17.3Regular Expressions A regular expression is a way of describing a sequence of characters.Regular expressions are a stunningly powerful computational device. However, describing the languages used to define regular expressions is well beyond the scope of this Primer. Instead, well focus on how to use the C++ regular-expression library (RE ++ library), which is part of the new library. The RE library, which is defined in the regex header, involves several components, listed in Table 17.4. If you are not already familiar with using regular expressions, you might want to skim this section to get an idea of the kinds of things regular expressions can do..",Specialised Library Facilities
Exercise 17.14,Write several regular expressions designed to trigger various errors. Run your program to see what output your compiler generates for each error.,Specialised Library Facilities
Exercise 17.15,"Write a program using the pattern that finds words that violate the i before e except after c"" rule. Have your program prompt the user to supply a word and indicate whether the word is okay or not. Test your program with words that do and do not violate the rule..",Specialised Library Facilities
Exercise 17.16,"What would happen if your regex object in the previous program were initialized with "" [^c] ei ""? Test your program using that pattern to see whether your expectations were correct. 17.3.2 The Match and Regex Iterator Types The program on page 729 that found violations of the ""i before e except after c"" grammar rule printed only the first match in its input sequence. We can get all the matches by using an sregex_iterator. The regex iterators are iterator adaptors (S 9.6, p. 368) that are bound to an input sequence and a regex object. As described in Table 17.8 (on the previous page), there are specific regex iterator types that cor- respond to each of the different types of input sequences. The iterator operations are described in Table 17.9 (p. 736). iterator is automatically positioned on the first match in the given string. That is, the sregex iterator constructor calls regex_search on the given string and regex. When we dereference the iterator, we get an smatch object corre- sponding to the results from the most recent search. When we increment the itera- tor, it calls regex search to find the next match in the input string. Using an sregex_iterator As an example, well extend our program to find all the violations of the ""i before. e except after c"" grammar rule in a file of text. Well assume that the string. named fi1e holds the entire contents of the input file that we want to search. This version of the program will use the same pattern as our original one, but will.. use a sregex iterator to do the search:",Specialised Library Facilities
Exercise 17.17,"Update your program so that it finds all the words in an input se-. quence that violiate the ""ei grammar rule.",Specialised Library Facilities
Exercise 17.18,"Revise your program to ignore words that contain ei but are not misspellings, such as ""albeit and neighbor.",Specialised Library Facilities
Exercise 17.19,Why is it okay to call m [4] . str () without first checking whether m [4] was matched?,Specialised Library Facilities
Exercise 17.20,Write your own version of the program to validate phone numbers,Specialised Library Facilities
Exercise 17.21,Rewrite your phone number program from $ 8.3.2 (p. 323) to use the valid function defined in this section.,Specialised Library Facilities
Exercise 17.22,Rewrite your phone program so that it allows any number of white- space characters to separate the three parts of a phone number..,Specialised Library Facilities
Exercise 17.23,"Write a regular expression to find zip codes. A zip code can have five or nine digits. The first five digits can be separated from the remaining four by a dash. 17.3.4  Using regex_replace Regular expressions are often used when we need not only to find a given sequence but also to replace that sequence with another one. For example, we might want to translate U.S. phone numbers into the form ""ddd.ddd.dddd,"" where the area code and next three digits are separated by a dot.",Specialised Library Facilities
Exercise 17.24,Write your own version of the program to reformat phone numbers.,Specialised Library Facilities
Exercise 17.25,Rewrite your phone program so that it writes only the first phone. number for each person.,Specialised Library Facilities
Exercise 17.26,Rewrite your phone program so that it writes only the second and subsequent phone numbers for people with more than one phone number..,Specialised Library Facilities
Exercise 17.27,Write a program that reformats a nine-digit zip code as ddddd-dddd..,Specialised Library Facilities
Exercise 17.28,Write a function that generates and returns a uniformly distributed. random unsigned int each time it is called..,Specialised Library Facilities
Exercise 17.29,Allow the user to supply a seed as an optional argument to the func- tion you wrote in the previous exercise..,Specialised Library Facilities
Exercise 17.30,"Revise your function again this time to take a minimum and maxi- mum value for the numbers that the function should return.. 17.4.2 Other Kinds of Distributions The engines produce unsigned numbers, and each number in the engine's range has the same likelihood of being generated. Applications often need numbers of different types or distributions. The library handles both these needs by defining different distributions that, when used with an engine, produce the desired results. Table 17.16 (overleaf) lists the operations supported by the distribution types.. Generating Random Real Numbers Programs often need a source of random floating-point values. In particular, pro- grams frequently need random numbers between zero and one.. The most common, but incorrect, way to obtain a random floating-point fror rand is to divide the result of rand () by RAND MAX, which is a system-defined upper limit that is the largest random number that rand can return. This technique is incorrect because random integers usually have less precision than floating-. point numbers, in which case there are some floating-point values that will never be produced as output.",Specialised Library Facilities
Exercise 17.31,What would happen if we defined b and e inside the do loop of the. game-playing program from this section?,Specialised Library Facilities
Exercise 17.32,What would happen if we defined resp inside the loop?.,Specialised Library Facilities
Exercise 17.33,"Write a version of the word transformation program from $ 11.3.6 (p. 440) that allows multiple transformations for a given word and randomly selectss. which transformation to apply. 17.5.1Formatted Input and Output In addition to its condition state (S 8.1.2, p. 312), each iost ream object also main tains a format state that controls the details of how IO is formatted. The format state controls aspects of formatting such as the notational base for integral values, the precision of floating-point values, the width of an output element, and so on. The library defines a set of manipulators (S 1.2, p. 7), listed in Tables 17.17 (p. 757) and 17.18 (p. 760), that modify the format state of a stream. A manipula- tor is a function or object that affects the state of a stream and can be used as an operand to an input or output operator. Like the input and output operators, a manipulator returns the stream object to which it is applied, so we can combine manipulators and data in a single statement. Our programs have already used one manipulator, end1, which we ""write"" to an output stream as if it were a value. But endl isn't an ordinary value; instead, it performs an operation: It writes a newline and flushes the buffer.. Many Manipulators Change the Format State Manipulators are used for two broad categories of output control: controlling the presentation of numeric values and controlling the amount and placement of padding. Most of the manipulators that change the format state provide set/unset pairs; one manipulator sets the format state to a new value and the other unsets it restoring the normal default formatting. Manipulators that change the format state of the stream usually leave. the format state changed for all subsequent IO. WARNING The fact that a manipulator makes a persistent change to the format state can be useful when we have a set of IO operations that want to use the same formatting Indeed, some programs take advantage of this aspect of manipulators to reset the behavior of one or more formatting rules for all its input or output. In such cases, the fact that a manipulator changes the stream is a desirable property.. However, many programs (and, more importantly, programmers) expect the state of the stream to match the normal library defaults. In these cases, leaving the state of the stream in a nonstandard state can lead to errors. As a result, it is usually best to undo whatever state changes are made as soon as those changes are no longer needed",Specialised Library Facilities
Exercise 17.34,Write a program that illustrates the use of each manipulator in Ta-. bles 17.17 (p. 757) and 17.18.,Specialised Library Facilities
Exercise 17.35,"Write a version of the program from page 758, that printed the square root of 2 but this time print hexadecimal digits in uppercase.",Specialised Library Facilities
Exercise 17.36,Modify the program from the previous exercise to print the various. floating-point values so that they line up in a column.,Specialised Library Facilities
Exercise 17.37,Use the unformatted version of get1ine to read a file a line at a time. Test your program by giving it a file that contains empty lines as well as lines that are longer than the character array that you pass to get1ine..,Specialised Library Facilities
Exercise 17.38,"Extend your program from the previous exercise to print each word you read onto its own line. not support random access-after all, what would it mean to jump back ten places when we're writing directly to cout? We can call the seek and tell functions, but these functions will fail at run time, leaving the stream in an invalid state. Because the istream and ostream types usually do not support ran dom access, the remainder of this section should be considered as appli WARNING cable to only the fstream and sstream types.",Specialised Library Facilities
Exercise 17.39,Write your own version of the seek program presented in this section.,Specialised Library Facilities
Exercise 18.1,"What is the type of the exception object in the following throws? (a) range_error r(""error""); (b) exception *p = &r; throw r; throw *p; What would happen if the throw in (b) were written as throw p?",Tools for Large Programs
Exercise 18.2,"Explain what happens if an exception occurs at the indicated point: void exercise(int *b, int *e) vector<int> v(b, e); int *p = new int[v.size()]; ifstream in(""ints""); J/exception occurs here }",Tools for Large Programs
Exercise 18.3,"There are two ways to make the previous code work correctly if an exception is thrown. Describe them and implement them. 18.1.2 Catching an Exception The exception declaration in a catch clause looks like a function parameter list with exactly one parameter. As in a parameter list, we can omit the name of the catch parameter if the cat ch has no need to access the thrown expression. The type of the declaration determines what kinds of exceptions the handler can catch. The type must be a complete type ($ 7.3.3, p. 278). The type can be an lvalue reference but may not be an rvalue reference (S 13.6.1, p. 532) When a cat ch is entered, the parameter in its exception declaration is initial ized by the exception object. As with function parameters, if the cat ch parameter has a nonreference type, then the parameter in the cat ch is a copy of the excep- tion object; changes made to the parameter inside the catch are made to a local copy, not to the exception object itself. If the parameter has a reference type, then like any reference parameter, the catch parameter is just another name for the exception object. Changes made to the parameter are made to the exception object. Also like a function parameter, a cat ch parameter that has a base-class type can be initialized by an exception object that has a type derived from the parameter type. If the cat ch parameter has a nonreference type, then the exception object",Tools for Large Programs
Exercise 18.4,"Looking ahead to the inheritance hierarchy in Figure 18.1 (p. 783), ex plain whats wrong with the following try block. Correct it. try{ //use of the C++ standard library } catch(exception){ //.. } catch(const runtime_error &re) { //.. } catch(overflow_error eobj) {/* .. */ }",Tools for Large Programs
Exercise 18.5,Modify the following main function to catch any of the exception types shown in Figure 18.1 (p. 783): int main() { //use of the C++ standard library The handlers should print the error message associated with the exception before call. ing abort (defined in the header cstdlib) to terminate main.,Tools for Large Programs
Exercise 18.6,"Given the following exception types and cat ch clauses, write a throw expression that creates an exception object that can be caught by each cat ch clause: a class exceptionType{}; catchexceptionType +pet) {} bcatch...{} (c) typedef int EXCPTYPE; catchEXCPTYPE){} the constructor body can't handle an exception thrown by a constructor initializer because a try block inside the constructor body would not yet be in effect when. the exception is thrown. To handle an exception from a constructor initializer, we must write the con- structor as a function try block. A function try block lets us associate a group. of catch clauses with the initialization phase of a constructor (or the destruction phase of a destructor) as well as with the constructor's (or destructor's) function body.As an example, we might wrap the B1ob constructors (S 16.1.2, p.662) in a function try block: template <typename T> Blob<T>::Blob(std::initializer list<T> il) try : data (std::make_shared<std::vector<T>>(il)){ /+ empty body+/ } catch(const std::bad_alloc &e) { handle_out_of_memory(e); } Notice that the keyword try appears before the colon that begins the constructor. initializer list and before the curly brace that forms the (in this case empty) con- structor function body. The cat ch associated with this try can be used to handle.",Tools for Large Programs
Exercise 18.7,"Define your B1ob and B1 obPt r classes from Chapter 16 to use function t ry blocks for their constructors. 18.1.4The noexcept Exception Specification. It can be helpful both to users and to the compiler to know that a function will not throw any exceptions. Knowing that a function will not throw simplifies the task of writing code that calls that function. Moreover, if the compiler knows that no exceptions will be thrown, it can (sometimes) perform optimizations that must be suppressed if code might throw. Under the new standard, a function can specify that it does not throw excep- tions by providing a noexcept specification. The keyword noexcept following the function parameter list indicates that the function won't throw: void recoup(int) noexcept; // wont throw void alloc(int); //might throw These declarations say that recoup will not throw any exceptions and that a11oc might. We say that recoup has a nonthrowing specification. The noexcept specifier must appear on all of the declarations and the corre sponding definition of a function or on none of them. The specifier precedes a. trailing return (S 6.3.3, p. 229). We may also specify noexcept on the declara- tion and definition of a function pointer. It may not appear in a typedef or type alias. In a member function the noexcept specifier follows any const or refer. ence qualifiers, and it precedes f ina1, override, or = 0 on a virtual function Violating the Exception Specification It is important to understand that the compiler does not check the noexcept spec. ification at compile time. In fact, the compiler is not permitted to reject a function with a noexcept specifier merely because it contains a throw or calls a function. that might throw (however, kind compilers will warn about such usages):",Tools for Large Programs
Exercise 18.8,"Review the classes you've written and add appropriate exception spec- ifications to their constructors and destructors. If you think one of your destructors. might throw, change the code so that it cannot throw. 18.1.5Exception Class Hierarchies The standard-library exception classes ($ 5.6.3, p. 197) form the inheritance hierar chy (Chapter 15) as shown in Figure 18.1. The only operations that the exception types define are the copy construc tor, copy-assignment operator, a virtual destructor, and a virtual member named what. The what function returns a const char* that points to a null-terminated character array, and is guaranteed not to throw any exceptions.. The exception, bad cast, and bad alloc classes also define a default con- structor. The runtime error and logic error classes do not have a default constructor but do have constructors that take a C-style character string or a library string argument. Those arguments are intended to give additional information about the error. In these classes, what returns the message used to initialize the exception object. Because what is virtual, if we catch a reference to the base-type,. a call to the what function will execute the version appropriate to the dynamic. type of the exception object Exception Classes for a Bookstore Application Applications often extend the exception hierarchy by defining classes derived from exception (or from one of the library classes derived from exception) These application-specific classes represent exceptional conditions specific to the application domain.",Tools for Large Programs
Exercise 18.9,Define the bookstore exception classes described in this section and rewrite your Sales_dat a compound assigment operator to throw an exception.,Tools for Large Programs
Exercise 18.10,Write a program that uses the Sales_data addition operator on ob- jects that have differing ISBNs. Write two versions of the program: one that handles the exception and one that does not. Compare the behavior of the programs so that you become familiar with what happens when an uncaught exception occurs..,Tools for Large Programs
Exercise 18.11,"Why is it important that the what function doesn't throw?. 18.2 Namespaces Large programs tend to use independently developed libraries. Such libraries also. tend to define a large number of global names, such as classes, functions, and. templates. When an application uses libraries from many different vendors, it is almost inevitable that some of these names will clash. Libraries that put names. into the global namespace are said to cause namespace pollution. names for the global entities they defined. Those names often contained a prefix. indicating which library defined the name: class cplusplus_primer_Query { ... }; string cplusplus_primer_make plural(size_t, string&); This solution is far from ideal: It can be cumbersome for programmers to write and read programs that use such long names.. Namespaces provide a much more controlled mechanism for preventing name collisions. Namespaces partition the global namespace. A namespace is a scope. By defining a library's names inside a namespace, library authors (and users) can avoid the limitations inherent in global names.. 18.2.1Namespace Definitions A namespace definition begins with the keyword namespace followed by the namespace name. Following the namespace name is a sequence of declarations. and definitions delimited by curly braces. Any declaration that can appear at global scope can be put into a namespace: classes, variables (with their initial- izations), functions (with their definitions), templates, and other namespaces: namespace cplusplus_primer { class Sales_data {/* ... */}; Sales_data operator+(const Sales_data&,. const Sales_data&) ; class Query {/*... */}; class Query base{/* ... */}; }I /like blocks, namespaces do not end with a semicolon.",Tools for Large Programs
Exercise 18.12,"Organize the programs you have written to answer the questions in. each chapter into their own namespaces. That is, namespace chapter15 would con- tain code for the Query programs and chapter10 would contain the TextQuery code. Using this structure, compile the Query code examples.",Tools for Large Programs
Exercise 18.13,When might you use an unnamed namespace?,Tools for Large Programs
Exercise 18.14,"Suppose we have the following declaration of the operator + that is. a member of the nested namespace mathLib: :MatrixLib: namespace mathLib { namespace MatrixLib { class matrix{/*...*/}; matrix operator* (const matrix &, const matrix &); How would you declare this operator in global scope? 18.2.2Using Namespace Members mittedly cumbersome, especially if the namespace name is long. Fortunately, there are ways to make it easier to use namespace members. Our programs have used one of these ways, us ing declarations ($ 3.1, p. 82). The others, namespace aliases. and us ing directives, will be described in this section. Namespace Aliases A namespace alias can be used to associate a shorter synonym with a namespace name. For example, a long namespace name such as namespace cplusplus_primer {/+...+/}; can be associated with a shorter synonym as follows: namespace primer = cplusplus primer;",Tools for Large Programs
Exercise 18.15,Explain the differences between using declarations and directives.,Tools for Large Programs
Exercise 18.16,Explain the following code assuming using declarations for all the members of namespace Exerci se are located at the location labeled position 1. What if they appear at position 2 instead? Now answer the same question but replace the using declarations with a using directive for namespace Exercise. namespace Exercise { int ivar = 0; double dvar = 0; const int limit = 1000; int ivar = 0; //position 1 void manip() { //position 2 double dvar = 3.1416; int iobj = limit + 1; ++ivar; ++::ivar;,Tools for Large Programs
Exercise 18.17,"Write code to test your answers to the previous question. 18.2.3 Classes, Namespaces, and Scope Name lookup for names used inside a namespace follows the normal lookup rules:. The search looks outward through the enclosing scopes. An enclosing scope might. be one or more nested namespaces, ending in the all-encompassing global name- space. Only names that have been declared before the point of use that are in blocks that are still open are considered: namespace A int i; namespace B{ int i; /hides A::i within B int j; int f1() { int j; //j is local to f1 and hides A::B::j return i; // returnsB::i I /namespace B is closed and names in it are no longer visible int f2{ return j; // error: j is not defined intj=i; //initialized from A:: i",Tools for Large Programs
Exercise 18.18,"Given the following typical definition of swap S 13.3 (p. 517), deter- mine which version of swap is used if mem1 is a string. What if meml is an int? Explain how name lookup works in both cases. void swap(T vl, T v2) using std::swap; swap(vl.meml, v2.meml) ; //swap remaining members of type T",Tools for Large Programs
Exercise 18.19,"What if the call to swap was std: : swap (v1.meml, v2 .mem1) ?",Tools for Large Programs
Exercise 18.20,"In the following code, determine which function, if any, matches the call to compute. List the candidate and viable functions. What type conversions, if any, are applied to the argument to match the parameter in each viable function? namespace primerLib {. void compute() ; void compute(const void *); using primerLib::compute; void compute(int); void compute(double, double = 3.4); void compute(char*, char* = 0); void f() compute (0) ; } What would happen if the using declaration were located in main before the call to comput e? Answer the same questions as before. 18.3 Multiple and Virtual Inheritance Multiple inheritance is the ability to derive a class from more than one direct base class (S 15.2.2, p. 600). A multiply derived class inherits the properties of all its parents. Although simple in concept, the details of intertwining multiple base classes can present tricky design-level and implementation-level problems. To explore multiple inheritance, we'll use a pedagogical example of a zoo an- imal hierarchy. Our zoo animals exist at different levels of abstraction. There are the individual animals, distinguished by their names, such as Ling-ling, Mowgli, and Balou. Each animal belongs to a species; Ling-Ling, for example, is a giant.",Tools for Large Programs
Exercise 18.21,"Explain the following declarations. Identify any that are in error and explain why they are incorrect:. a) class CADvehicle : public CAD, Vehicle { ... }; (b) class DblList: public List, public List { ... }; (c) class iostream: public istream, public ostream { ... };",Tools for Large Programs
Exercise 18.22,"Given the following class hierarchy, in which each class defines a de fault constructor: classA{...} class B : public A { class C : public B { class X{ class Y .}; class Z : public x, public y{... } class MI : public C, public Z { ... }; what is the order of constructor execution for the following definition?. MI mi; refer to a derived object. For example, a pointer or reference to ZooAnima1, Bear, or Endangered can be bound to a Panda object:. I /operations that take references to base classes of type Panda void print (const Bear&); void highlight (const Endangered&) ; ostream& operator<<(ostream&, const ZooAnimal&) ; Panda ying_yang(""ying_yang""); print(ying_yang); I/passes Panda to a reference to Bear highlight (ying_yang) ; // passes Panda to areference to Endangered. cout << ying_yang << endl; // passes Panda toa reference to ZooAnimal The compiler makes no attempt to distinguish between base classes in terms. of a derived-class conversion. Converting to each base class is equally good. For. example, if there was an overloaded version of print: void print (const Bear&); void print(const Endangered&) ; an unqualified call to print with a Panda object would be a compile-time error: Panda ying_yang(""ying_yang""); print(ying_yang) ; //error: ambiguous Lookup Based on Type of Pointer or Reference. As with single inheritance, the static type of the object, pointer, or reference deter- mines which members we can use (S 15.6, p. 617). If we use a ZooAnima1 pointer,",Tools for Large Programs
Exercise 18.23,"Using the hierarchy in exercise 18.22 along with class D defined below, and assuming each class defines a default constructor, which, if any, of the following conversions are not permitted? class D : public X, public c {... }, D *pd = new D; ax*px=pd bA *pa=pd cB *pb=pd dc *pc=pd",Tools for Large Programs
Exercise 18.24,On page 807 we presented a series of calls made through a Bear pointer that pointed to a Panda object. Explain each call assuming we used a ZooAnima1 pointer pointing to a Panda object instead.,Tools for Large Programs
Exercise 18.25,"Assume we have two base classes, Base1 and Base2, each of which defines a virtual member named print and a virtual destructor. From these base classes we derive the following classes, each of which redefines the print function: class Dl : public Basel {/* ...*/ }; class D2 :public Base2 {/ ...*/}; class MI : public D1, public D2 {/* ... */ }; Using the following pointers, determine which function is used in each call Basel *pbl = new MI; Base2 *pb2 = new MI; D1 *pdl = new MI; D2 *pd2 = new MI; a pb1->print; b pd1->print; cpd2->print; (d) delete pb2; (e) delete pdl; f delete pd2; In our example, if we use a name through a Panda object, pointer, or reference,. both the Endangered and the Bear/ZooAnimal subtrees are examined in par- allel. If the name is found in more than one subtree, then the use of the name is ambiguous. It is perfectly legal for a class to inherit multiple members with the same name. However, if we want to use that name, we must specify which version we want to use. When a class has multiple base classes, it is possible for that derived class to inherit a member with the same name from two or more of its WARNING base classes. Unqualified uses of that name are ambiguous. For example, if both ZooAnimal and Endangered define a member named. max_weight, and Panda does not define that member, this call is an error: double d = ying_yang.max_weight(); The derivation of Panda, which results in Panda having two members named. max weight, is perfectly legal. The derivation generates a potential ambiguity That ambiguity is avoided if no Panda object ever calls max_weight. The error",Tools for Large Programs
Exercise 18.26,"Given the hierarchy in the box on page 810, why is the following call to print an error? Revise MI to allow this call to pr int to compile and execute correctly MI mi; mi.print(42);",Tools for Large Programs
Exercise 18.27,Given the class hierarchy in the box on page 810 and assuming we add a function named foo to MI as follows: int ival; double dval; void MI::foo(double cval) int dval; //exercise questions occur here. (a) List all the names visible from within MI : : f oo (b) Are any names visible from more than one base class?. (c) Assign to the local instance of dva1 the sum of the dva1 member of Base1 and the dval member of Derived. (d) Assign the value of the last element in MI : : dvec to Base2 : : fva1 (e) Assign cval from Base1 to the first character in sva1 from Derived..,Tools for Large Programs
Exercise 18.28,"Given the following class hierarchy, which inherited members can be accessed without qualification from within the vMI class? Which require qualification? Explain your reasoning.. struct Base { void bar(int); // publicby default protected: int ival; }; struct Derivedl : virtual public Base { void bar(char);// publicbydefault void foo(char); protected: char cval; !{ struct Derived2 : virtual public Base { void foo(int); //publicby default protected: int ival; char cval; { class VMI : public Derivedl, public Derived2 { }; 18.3.5Constructors and Virtual Inheritance In a virtual derivation, the virtual base is initialized by the most derived construc tor. In our example, when we create a Panda object, the Panda constructor alone controls how the ZooAnima1 base class is initialized.. To understand this rule, consider what would happen if normal initializatior rules applied. In that case, a virtual base class might be initialized more than once. It would be initialized along each inheritance path that contains that virtual base In our ZooAnima1 example, if normal initialization rules applied, both Bear and Raccoon would initialize the ZooAnimal part of a Panda object.. Of course, each class in the hierarchy might at some point be the ""most de- rived"" object. As long as we can create independent objects of a type derived from",Tools for Large Programs
Exercise 18.29,"Given the following class hierarchy class Class{...}; class Base : public Class {... } class D1 : virtual public Base { class D2 : virtual public Base { class MI : public Dl, public D2 { ... }; class Final : public MI, public Class { ... }; (a) In what order are constructors and destructors run on a Fina1 object? (b) A Final object has how many Base parts? How many Class parts? (c) Which of the following assignments is a compile-time error? Base *pb; Class *pc; MI *pmi; D2 *pd2; a) pb = new Class; (b) pc = new Final; cpmi=pb; d pd2 = pmi;",Tools for Large Programs
Exercise 18.30,"Define a default constructor, a copy constructor, and a constructor that has an int parameter in Base. Define the same three constructors in each derived class. Each constructor should use its argument to initialize its Base part.",Tools for Large Programs
Exercise 19.1,Write your own operator new (size_t) function using malloc and use free to write the operator delete (void+) function..,Specialised Tools and Techniques
Exercise 19.2,"By default, the a1locator class uses operator new to obtain storage and operator delete to free it. Recompile and rerun your StrVec programs ($ 13.5, p. 526) using your versions of the functions from the previous exercise. 19.1.2Placement new Expressions Although the operator new and operator delete functions are intended to be used by new expressions, they are ordinary functions in the library. As a result. ordinary code can call these functions directly. In earlier versions of the language-before the a1locator (S 12.2.2, p. 481) class was part of the library-applications that wanted to separate allocation from initialization did so by calling operator new and operator delete. These functions behave analogously to the allocate and deallocate members of allocator. Like those members, operator new and operator delete func tions allocate and deallocate memory but do not construct or destroy objects.",Specialised Tools and Techniques
Exercise 19.3,"Given the following class hierarchy in which each class defines a publ i c default constructor and virtual destructor: classA/*... classB:publicA{/... */}; class C : publicB /*... +/}; class D:public B,publicA{/*... */ }; which, if any, of the following dynamic_casts fail?. a A *pa =new C; B *pb = dynamic_cast< B* >pa); b B *pb =new B; C *pc = dynamic_cast< C* >pb); c A *pa =new D; B *pb = dynamic_cast< B >(pa);",Specialised Tools and Techniques
Exercise 19.4,"Using the classes defined in the first exercise, rewrite the following code to convert the expression +pa to the type C&: if (C *pc = dynamic_cast< C* >(pa)) //use C's members else //use As members",Specialised Tools and Techniques
Exercise 19.5,"When should you use a dynamic_cast instead of a virtual function? A typeid expression has the form typeid (e) where e is any expression or a type name. The result of a typeid operation is a reference to a const object of a library type named type_info, or a type publicly derived from type_info. S 19.2.4 (p. 831) covers this type in more detail. The type_info class is defined in the typeinfo header. The typeid operator can be used with expressions of any type. As usual, top-level const (S 2.4.3, p. 63) is ignored, and if the expression is a reference, typeid returns the type to which the reference refers. When applied to an array or function, however, the standard conversion to pointer (S 4.11.2, p. 161) is not done. That is, if we take typeid (a) and a is an array, the result describes an array type, not a pointer type. When the operand is not of class type or is a class without virtual functions then the typeid operator indicates the static type of the operand. When the oper- and is an lvalue of a class type that defines at least one virtual function, then the type is evaluated at run time. Using the typeid Operator Ordinarily, we use typeid to compare the types of two expressions or to compare the type of an expression to a specified type:",Specialised Tools and Techniques
Exercise 19.6,"Write an expression to dynamically cast a pointer to a Query_base to a pointer to an AndQuery (S 15.9.1, p. 636). Test the cast by using objects of AndQuery and of another query type. Print a statement indicating whether the cast works and be sure that the output matches your expectations.",Specialised Tools and Techniques
Exercise 19.7,"Write the same cast, but cast a Query_base object to a reference to AndQuery. Repeat the test to ensure that your cast works correctly..",Specialised Tools and Techniques
Exercise 19.8,"Write a typeid expression to see whether two Query_base pointers point to the same type. Now check whether that type is an AndQuery We might think we could solve this problem by defining a set of virtual func tions that would perform the equality test at each level in the hierarchy. Given those virtuals, we would define a single equality operator that operates on refer- ences to the base type. That operator could delegate its work to a virtual equal operation that would do the real work. Unfortunately, this strategy doesn't quite work. Virtual functions must have the same parameter type(s) in both the base and derived classes ($ 15.3, p. 605). I we wanted to define a virtual equa1 function, that function must have a parameter that is a reference to the base class. If the parameter is a reference to base, the equa1 function could use only members from the base class. equa1 would have no way to compare members that are in the derived class but not in the base. We can write our equality operation by realizing that the equality operator. ought to return false if we attempt to compare objects of differing type. For. example, if we try to compare a object of the base-class type with an object of a derived type, the == operator should return false. Given this observation, we can now see that we can use RTTI to solve our prob- lem. Well define an equality operator whose parameters are references to the base- class type. The equality operator will use typeid to verify that the operands have the same type. If the operands differ, the == will return fa1 se. Otherwise, it will call a virtual equa1 function. Each class will define equal to compare the data elements of its own type. These operators will take a Base& parameter but wil cast the operand to its own type before doing the comparison.. The Class Hierarchy To make the concept a bit more concrete, well define the following classes class Base { friend bool operator==(const Base&, const Base&); public: //interface members for Base protected: virtual bool equal(const Base&) const; / /data and other implementation members of Base } ;",Specialised Tools and Techniques
Exercise 19.9,"Write a program similar to the last one in this section to print the names your compiler uses for common type names. If your compiler gives output similar to ours, write a function that will translate those strings to more human-friendly form.",Specialised Tools and Techniques
Exercise 19.10,"Given the following class hierarchy in which each class defines a public default constructor and virtual destructor, which type name do the follow- ing statements print? classA{/...*/}; class B:publicA{/*...*/} class CpublicB{/*...*} a A *pa =new C; cout << typeid(pa).name() << endl; b C cobj; A& ra = cobj; cout << typeid(&ra).name() << endl; c B *px=new B; A& ra = *px; cout << typeid(ra).name() << endl; 19.3 Enumerations Enumerations let us group together sets of integral constants. Like classes, each enumeration defines a new type. Enumerations are literal types ($ 7.5.6, p. 299) C++ has two kinds of enumerations: scoped and unscoped. The new standard. introduced scoped enumerations. We define a scoped enumeration using the key words enum class (or, equivalently, enum struct), followed by the enumera- tion name and a comma-separated list of enumerators enclosed in curly braces. A semicolon follows the close curly: enum class open_modes {input, output, append}; Here we defined an enumeration type named open_modes that has three enumer- ators: input, output, and append.. We define an unscoped enumeration by omitting the class (or struct) key- word. The enumeration name is optional in an unscoped enum: enum color {red, yellow, green}; //unscoped enumeration //unnamed, unscoped enum enum {floatPrec = 6, doublePrec = 10, double_doublePrec = 10}; If the enum is unnamed, we may define objects of that type only as part of the enum definition. As with a class definition, we can provide a comma-separated. list of declarators between the close curly and the semicolon that ends the enum definition (S 2.6.1, p. 73)",Specialised Tools and Techniques
Exercise 19.11,What is the difference between an ordinary data pointer and a pointer. to a data member?,Specialised Tools and Techniques
Exercise 19.12,Define a pointer to member that can point to the cursor member of. class Screen. Fetch the value of Screen : : cursor through that pointer.,Specialised Tools and Techniques
Exercise 19.13,"Define the type that can represent a pointer to the bookNo member of the Sales_data class.. 19.4.2Pointers to Member Functions We can also define a pointer that can point to a member function of a class. As with pointers to data members, the easiest way to form a pointer to member function is to use auto to deduce the type for us:. / /pmf is a pointer that can point to a Screen member function that is const //that returns a char and takes no arguments auto pmf = &Screen::get_cursor; Like a pointer to data member, a pointer to a function member is declared using classname: : *.Like any other function pointer (S 6.7,p.247), a pointer to mem- ber function specifies the return type and parameter list of the type of function to. which this pointer can point. If the member function is a const member ($ 7.1.2 p. 258) or a reference member (S 13.6.3, p. 546), we must include the const or reference qualifier as well.. As with normal function pointers, if the member is overloaded, we must dis-. tinguish which function we want by declaring the type explicitly (S 6.7, p. 248). For example, we can declare a pointer to the two-parameter version of get as char (Screen::*pmf2) (Screen::pos, Screen::pos) const; pmf2 = &Screen::get; The parentheses around Screen : : * in this declaration are essential due to prece- dence. Without the parentheses, the compiler treats the following as an (invalid) function declaration: / /error: nonmember function p cannot have a const qualifier char Screen::*p(Screen::pos, Screen::pos) const; This declaration tries to define an ordinary function named p that returns a pointer to a member of class Screen that has type char. Because it declares an ordinary function, the declaration can't be followed by a const qualifier. Unlike ordinary function pointers, there is no automatic conversion between a member function and a pointer to that member:. / /pmf points to a Screen member that takes no arguments and returns char pmf = &Screen::get; //must explicitly use the address-of operator pmf = Screen: : get; / /error: no conversion to pointer for member functions",Specialised Tools and Techniques
Exercise 19.14,"Is the following code legal? If so, what does it do? If not, why?. auto pmf = &Screen::get_cursor; pmf = &Screen::get;",Specialised Tools and Techniques
Exercise 19.15,What is the difference between an ordinary function pointer and a pointer to a member function?,Specialised Tools and Techniques
Exercise 19.16,Write a type alias that is a synonym for a pointer that can point to the. avg_price memberof Sales_data.,Specialised Tools and Techniques
Exercise 19.17,"Define a type alias for each distinct Screen member function type 19.4.3Using Member Functions as Callable Objects As we've seen, to make a call through a pointer to member function, we must use the .  or - > operators to bind the pointer to a specific object. As a result",Specialised Tools and Techniques
Exercise 19.18,Write a function that uses count_if to count how many empty strings there are in a given vector.,Specialised Tools and Techniques
Exercise 19.19,"Write a function that takes a vector<Sales_data> and finds the first element whose average price is greater than some given amount. Nested classes are independent classes and are largely unrelated to their enclos ing class. In particular, objects of the enclosing and nested classes are independent from each other. An object of the nested type does not have members defined by the enclosing class. Similarly, an object of the enclosing class does not have mem- bers defined by the nested class. The name of a nested class is visible within its enclosing class scope but not. outside the class. Like any other nested name, the name of a nested class will not. collide with the use of that name in another scope. A nested class can have the same kinds of members as a nonnested class. Just. like any other class, a nested class controls access to its own members using access. specifiers. The enclosing class has no special access to the members of a nested class, and the nested class has no special access to members of its enclosing class A nested class defines a type member in its enclosing class. As with any other member, the enclosing class determines access to this type. A nested class defined in the public part of the enclosing class defines a type that may be used any where. A nested class defined in the protected section defines a type that is ac- cessible only by the enclosing class, its friends, and its derived classes. A private nested class defines a type that is accessible only to the members and friends of the enclosing class. Declaring a Nested Class The TextQuery class from $ 12.3.2 (p. 487) defined a companion class named QueryResult. The QueryResult class is tightly coupled to our TextQuery class. It would make little sense to use QueryResult for any other purpose than to represent the results of a query operation on a TextQuery object. To reflect this tight coupling, well make QueryResult a member of TextQuery class TextQuery { public: class QueryResult;//nested class to be defined later //other members as in  12.3.2 (p. 487) 1{ We need to make only one change to our original TextQuery class-we declare our intention to define QueryResu1t as a nested class. Because QueryResult is a type member ($ 7.4.1, p. 284), we must declare QueryResu1t before we use it. In particular, we must declare QueryResu1t before we use it as the return type for the query member. The remaining members of our original class are unchanged.",Specialised Tools and Techniques
Exercise 19.20,"Nest your QueryResult class inside TextQuery and rerun the pro. grams you wrote to use Text Query in  12.3.2 (p. 490), 19.6 union: A Space-Saving Class. A union is a special kind of class. A union may have multiple data members, but at any point in time, only one of the members may have a value. When a value is assigned to one member of the uni on, all other members become undefined. The. amount of storage allocated for a union is at least as much as is needed to contain its largest data member. Like any class, a union defines a new type. Some, but not all, class features apply equally to unions. A union cannot have a member that is a reference, but it can have members of most other types including, under the new standard, class types that have constructors or destruc tors. A union can specify protection labels to make members public, private, or protected. By default, like structs, members of a union are public. A union may define member functions, including constructors and destruc- tors. However, a union may not inherit from another class, nor may a union be. used as a base class. As a result, a union may not have virtual functions. Defining a union unions offer a convenient way to represent a set of mutually exclusive values of. different types. As an example, we might have a process that handles different kinds of numeric or character data. That process might define a union to hold these values: J /  objects of type Token have a single member, which could be of any of the listed types union Token { //members are public by default char cval; int ival; double dval; }; A union is defined starting with the keyword union, followed by an (optional) name for the union and a set of member declarations enclosed in curly braces This code defines a union named Token that can hold a value that is either a char, an int, or a double.",Specialised Tools and Techniques
Exercise 19.21,Write your own version of the Token class.,Specialised Tools and Techniques
Exercise 19.22,Add a member of type Sales data to your Token class.,Specialised Tools and Techniques
Exercise 19.23,Add a move constructor and move assignment to Token,Specialised Tools and Techniques
Exercise 19.24,Explain what happens if we assign a Token object to itself.,Specialised Tools and Techniques
Exercise 19.25,"Write assignment operators that take values of each type in the uni on 19.7Local Classes A class can be defined inside a function body. Such a class is called a local class. A local class defines a type that is visible only in the scope in which it is defined. Unlike nested classes, the members of a local class are severely restricted All members, including functions, of a local class must be completely Note defined inside the class body. As a result, local classes are much less useful than nested classes.",Specialised Tools and Techniques
